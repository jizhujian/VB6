/*
  ComCtlTLB - Typelib for Common Controls 6.1 (Vista+)
    Based on CommCtrl.idl TLB by E. Morcillo
	Updated with 6.1 definitions by J. Johnson (fafalone)
	Important: ListView definitions include undocumented declares/interfaces
*/



[
    uuid(7e1244d7-2978-447b-8597-d204bd48120b),
    helpstring("Common Controls 6.1"),
    version(6.1)
]
library ComCtlTLB
{

    importlib("stdole32.tlb");

typedef void            *LPVOID;  //1.83 added
typedef unsigned char BYTE;
typedef long      COLORREF;
typedef long      DWORD;
typedef long      UINT;
typedef [public] LONG BOOL;
typedef long      HBITMAP;

typedef struct UUID {
    LONG Data1;
    SHORT Data2;
    SHORT Data3;
    BYTE Data4[8];
} UUID;
typedef struct PROPERTYKEY {
	UUID fmtid;
	LONG pid;
} PROPERTYKEY;
//typedef struct SYSTEMTIME {
//    short wYear;
//    short wMonth;
//    short wDayOfWeek;
//    short wDay;
//    short wHour;
//    short wMinute;
//    short wSecond;
//    short wMilliseconds;
//} SYSTEMTIME;

//typedef enum LVARENUM {
//    VT_EMPTY = 0,
//    VT_NULL = 1,
//    VT_I2 = 2,
//    VT_I4 = 3,
//    VT_R4 = 4,
//    VT_R8 = 5,
//    VT_CY = 6,
//    VT_DATE = 7,
//    VT_BSTR = 8,
//    VT_DISPATCH = 9,
//    VT_ERROR = 10,
//    VT_BOOL = 11,
//    VT_VARIANT = 12,
//    VT_UNKNOWN = 13,
//    VT_DECIMAL = 14,
//    VT_I1 = 16,
//    VT_UI1 = 17,
//    VT_UI2 = 18,
//    VT_UI4 = 19,
//    VT_I8 = 20,
//    VT_UI8 = 21,
//    VT_INT = 22,
//    VT_UINT = 23,
//    VT_VOID = 24,
//    VT_HRESULT = 25,
//    VT_PTR = 26,
//    VT_SAFEARRAY = 27,
//    VT_CARRAY = 28,
//    VT_USERDEFINED = 29,
//    VT_LPSTR = 30,
//    VT_LPWSTR = 31,
//    VT_FILETIME = 64,
//    VT_BLOB = 65,
//    VT_STREAM = 66,
//    VT_STORAGE = 67,
//    VT_STREAMED_OBJECT = 68,
//    VT_STORED_OBJECT = 69,
//    VT_BLOB_OBJECT = 70,
//    VT_CF = 71,
//    VT_CLSID = 72,
//    VT_STREAMED_PROPSET = 73,
//    VT_STORED_PROPSET = 74,
//    VT_BLOB_PROPSET = 75,
//    VT_VERBOSE_ENUM = 76,
//    VT_BSTR_BLOB = 0xFFF,
//    VT_VECTOR = 0x1000,
//    VT_ARRAY = 0x2000,
//    VT_BYREF = 0x4000,
//    VT_RESERVED = 0x8000,
//    VT_ILLEGAL = 0xffff,
//    VT_ILLEGALMASKED = 0x0fff,
//    VT_TYPEMASK = 0x0fff
//} LVARENUM;
    typedef enum ICC_CLASSES {
        [helpstring("listview, header")]
        ICC_LISTVIEW_CLASSES = 0x00000001,
        [helpstring("treeview, tooltips ")]
        ICC_TREEVIEW_CLASSES = 0x00000002,
        [helpstring("toolbar, statusbar, trackbar, tooltips ")]
        ICC_BAR_CLASSES = 0x00000004,
        [helpstring("tab, tooltips")]
        ICC_TAB_CLASSES = 0x00000008,
        [helpstring("updown")]
        ICC_UPDOWN_CLASS = 0x00000010,
        [helpstring("progress ")]
        ICC_PROGRESS_CLASS = 0x00000020,
        [helpstring("hotkey ")]
        ICC_HOTKEY_CLASS = 0x00000040,
        [helpstring("animate")]
        ICC_ANIMATE_CLASS = 0x00000080,
        ICC_WIN95_CLASSES = 0x000000FF,
        [helpstring("month picker, date picker, time picker, updown")]
        ICC_DATE_CLASSES = 0x00000100,
        [helpstring("comboex")]
        ICC_USEREX_CLASSES = 0x00000200,
        [helpstring("rebar (coolbar) control")]
        ICC_COOL_CLASSES = 0x00000400,
        ICC_INTERNET_CLASSES = 0x00000800,
        [helpstring("page scroller ")]
        ICC_PAGESCROLLER_CLASS = 0x00001000,
        [helpstring("native font control")]
        ICC_NATIVEFNTCTL_CLASS = 0x00002000,
		[helpstring("Standard classes")]
		ICC_STANDARD_CLASSES = 0x00004000,
		[helpstring("Link class")]
		ICC_LINK_CLASS = 0x00008000
    } ICC_CLASSES;

    typedef struct INITCOMMONCONTROLSEXst {
        [helpstring("Size of this structure")]
        LONG dwSize;
        [helpstring("Flags indicating which classes to be initialized")]
        ICC_CLASSES dwICC;
    } INITCOMMONCONTROLSEXst;

    [
        helpstring("Common Controls"),
        dllname("comctl32.dll")
    ]
    module Common {
        const LONG LPSTR_TEXTCALLBACK = -1;
        const LONG INFOTIPSIZE = 1024;
		const LPSTR WC_BUTTONA = "Button";
		const LPSTR WC_BUTTONW = "Button";
		const LPSTR WC_BUTTON = "Button";
		const LONG BCCL_NOGLYPH = (-1);
		const LONG L_MAX_URL_LENGTH = (2084);

        [entry("InitCommonControlsEx")]
        BOOL InitCommonControlsEx(
            [in] INITCOMMONCONTROLSEXst * ICC);

        [entry("InitCommonControls")]
        void InitCommonControls();

		[entry("LoadIconMetric")]
		int LoadIconMetric(
			[in] LONG hinst,
			[in] LONG pszName,
			[in] LONG lims,
			[out] LONG *phico);

		[entry("LoadIconWithScaleDown")]
		int LoadIconWithScaleDown(
			[in] LONG hinst,
			[in] LONG pszName,
			[in] LONG cx,
			[in] LONG cy,
			[out] LONG *phico);

    }

    typedef struct NMHDR {
        LONG hWndFrom;
        LONG idFrom;
        LONG code;
    } NMHDR;

    typedef enum ODT {
        ODT_HEADER = 100,
        ODT_TAB = 101,
        ODT_LISTVIEW = 102,
    } ODT;

 // ====== COMMON CONTROL STYLES =====================

    typedef enum CommonStyles {
        CCS_TOP = 0x00000001,
        CCS_NOMOVEY = 0x00000002,
        CCS_BOTTOM = 0x00000003,
        CCS_NORESIZE = 0x00000004,
        CCS_NOPARENTALIGN = 0x00000008,
        CCS_ADJUSTABLE = 0x00000020,
        CCS_NODIVIDER = 0x00000040,
        CCS_VERT = 0x00000080,
        CCS_LEFT = (CCS_VERT | CCS_TOP),
        CCS_RIGHT = (CCS_VERT | CCS_BOTTOM),
        CCS_NOMOVEX = (CCS_VERT | CCS_NOMOVEY),
    } ComCtlStyles;

    typedef enum CommonMessages {
        CCM_FIRST = 0x2000, // Common control shared messages
        CCM_SETBKCOLOR = 0x2001, // lParam is bkColor
        CCM_SETCOLORSCHEME = 0x2002, // lParam is color scheme
        CCM_GETCOLORSCHEME = (CCM_FIRST + 3), // fills in COLORSCHEME pointed to by lParam
        CCM_GETDROPTARGET = (CCM_FIRST + 4),
        CCM_SETUNICODEFORMAT = (CCM_FIRST + 5),
        CCM_GETUNICODEFORMAT = (CCM_FIRST + 6),
        CCM_SETVERSION = (CCM_FIRST + 0x7),
        CCM_GETVERSION = (CCM_FIRST + 0x8),
        CCM_SETNOTIFYWINDOW = (CCM_FIRST + 0x9), // wParam = hwndParent.
		CCM_SETWINDOWTHEME = (CCM_FIRST + 0xb),
		CCM_DPISCALE =(CCM_FIRST + 0xc), // wParam == Awareness
		CCM_TRANSLATEACCELERATOR = (0x400 + 97),
    } CommonMessages;

    typedef struct COLORSCHEME {
        LONG dwSize;
        LONG clrBtnHighlight; // highlight color
        LONG clrBtnShadow; // shadow color
    } COLORSCHEME;

    typedef enum NotificationCodes {
        NM_FIRST = 0, // generic to all controls
        NM_OUTOFMEMORY = (-1),
        NM_CLICK = (-2),
        NM_DBLCLK = (-3),
        NM_RETURN = (-4),
        NM_RCLICK = (-5),
        NM_RDBLCLK = (-6),
        NM_SETFOCUS = (-7),
        NM_KILLFOCUS = (-8),
        NM_CUSTOMDRAW = (-12),
        NM_HOVER = (-13),
        NM_NCHITTEST = (-14), // uses NMMOUSE struct
        NM_KEYDOWN = (-15),
        NM_RELEASEDCAPTURE = (-16),
        NM_SETCURSOR = (-17), // uses NMMOUSE struct
        NM_CHAR = (NM_FIRST-18), // uses NMCHAR struct
        NM_TOOLTIPSCREATED = (NM_FIRST-19), // notify of when the tooltips window is create
        NM_LDOWN = (NM_FIRST-20),
        NM_RDOWN = (NM_FIRST-21),
		NM_THEMECHANGED         = (NM_FIRST-22),
		NM_FONTCHANGED          = (NM_FIRST-23),
		NM_CUSTOMTEXT           = (NM_FIRST-24),  // uses NMCUSTOMTEXT struct
		NM_TVSTATEIMAGECHANGING = (NM_FIRST-24),   // uses NMTVSTATEIMAGECHANGING struct, defined after HTREEITEM

        NM_LAST = (-99)
    } NotificationCodes;

//    typedef struct RECT {
//        LONG Left;
//        LONG Top;
//        LONG Right;
//        LONG Bottom;
//    } RECT;
	typedef struct NMCUSTOMTEXT
	{
		NMHDR hdr;
		LONG hDC;
		LONG lpString;
		int nCount;
		RECT lpRect;
		LONG uFormat;
		LONG fLink;
	} NMCUSTOMTEXT;
	typedef struct NMTVSTATEIMAGECHANGING
	{
		NMHDR hdr;
		LONG hti;
		int iOldStateImageIndex;
		int iNewStateImageIndex;
	} NMTVSTATEIMAGECHANGING;

    typedef struct NMTOOLTIPSCREATED {
        NMHDR hdr;
        LONG hwndToolTips;
    } NMTOOLTIPSCREATED;

    typedef struct NMMOUSE {
        NMHDR   hdr;
        LONG dwItemSpec;
        LONG dwItemData;
        POINT pt;
        [helpstring("any specifics about where on the item or control the mouse is")]
        LONG dwHitInfo;
    } NMMOUSE, NMCLICK;

    typedef struct NMOBJECTNOTIFY {
        NMHDR   hdr;
        LONG iItem;
        LONG piid;
        LONG pObject;
        LONG hResult;
        [helpstring("control specific flags (hints as to where in iItem it hit)")]
        LONG dwFlags;
    } NMOBJECTNOTIFY;

    typedef struct NMKEY {
        NMHDR hdr;
        short wVKey;
        LONG flags;
    } NMKEY;

    typedef struct NMCHAR {
        NMHDR hdr;
        LONG ch;
        LONG dwItemPrev; // Item previously selected
        LONG dwItemNext; // Item to be selected
    } NMCHAR;

    typedef enum MSGFs {
        MSGF_COMMCTRL_BEGINDRAG = 0x4200,
        MSGF_COMMCTRL_SIZEHEADER = 0x4201,
        MSGF_COMMCTRL_DRAGSELECT = 0x4202,
        MSGF_COMMCTRL_TOOLBARCUST = 0x4203,
    } MSGFs;

    typedef enum CustomDrawReturnFlags {
        CDRF_DODEFAULT = 0x00000000,
        CDRF_NEWFONT = 0x00000002,
        CDRF_SKIPDEFAULT = 0x00000004,
		CDRF_DOERASE = 0x00000008, // draw the background

        CDRF_NOTIFYPOSTPAINT = 0x00000010,
        CDRF_NOTIFYITEMDRAW = 0x00000020,
        CDRF_NOTIFYSUBITEMDRAW = 0x00000020, // flags are the same, we can distinguish by context
        CDRF_NOTIFYPOSTERASE = 0x00000040,
		CDRF_SKIPPOSTPAINT = 0x00000100 // don't draw the focus rect

    } CustomDrawReturnFlags;

    typedef enum DrawStageFlags {
        CDDS_PREPAINT = 0x00000001,
        CDDS_POSTPAINT = 0x00000002,
        CDDS_PREERASE = 0x00000003,
        CDDS_POSTERASE = 0x00000004,
        [helpstring("CDDS_ITEM means it's individual item specific ")]
        CDDS_ITEM = 0x00010000,
		CDDS_ITEMPREPAINT = 0x00010001,  //    (CDDS_ITEM | CDDS_PREPAINT)
		CDDS_ITEMPOSTPAINT = 0x00010002, //    (CDDS_ITEM | CDDS_POSTPAINT)
		CDDS_ITEMPREERASE  = 0x00010003, //     (CDDS_ITEM | CDDS_PREERASE)
		CDDS_ITEMPOSTERASE = 0x00010004, //     (CDDS_ITEM | CDDS_POSTERASE)
        CDDS_SUBITEM = 0x00020000,
    } DrawStageFlags;

    typedef enum ItemStateFlags {
        CDIS_SELECTED = 0x0001,
        CDIS_GRAYED = 0x0002,
        CDIS_DISABLED = 0x0004,
        CDIS_CHECKED = 0x0008,
        CDIS_FOCUS = 0x0010,
        CDIS_DEFAULT = 0x0020,
        CDIS_HOT = 0x0040,
        CDIS_MARKED = 0x0080,
        CDIS_INDETERMINATE = 0x0100,
		CDIS_SHOWKEYBOARDCUES  = 0x0200,
		CDIS_NEARHOT           = 0x0400,
		CDIS_OTHERSIDEHOT      = 0x0800,
		CDIS_DROPHILITED       = 0x1000
    } ItemStateFlags;

    typedef struct NMCUSTOMDRAW {
        NMHDR hdr;
        LONG dwDrawStage;
        LONG hdc;
        RECT rc;
        [helpstring("this is control specific, but it's how to specify an item.  valid only with CDDS_ITEM bit set ")]
        LONG dwItemSpec;
        ItemStateFlags uItemState;
        LONG lParam;
    } NMCUSTOMDRAW;

    typedef struct NMTTCUSTOMDRAW {
        NMCUSTOMDRAW nmcd;
        LONG uDrawFlags;
    } NMTTCUSTOMDRAW;

	typedef struct tagNMCUSTOMSPLITRECTINFO
	{
		NMHDR hdr;
		RECT rcClient;
		RECT rcButton;
		RECT rcSplit;
	} NMCUSTOMSPLITRECTINFO;

// = BUTTON CONTROL ==================

	typedef enum ButtonStates 
	{
		BST_HOT           = 0x0200,
		BST_DROPDOWNPUSHED  =  0x0400
	} ButtonStates;
	typedef enum ButtonNotifications
	{
        BN_CLICKED         = 0,
        BN_PAINT           = 1,
        BN_HILITE          = 2,
        BN_UNHILITE        = 3,
        BN_DISABLE         = 4,
        BN_DOUBLECLICKED   = 5,
        BN_PUSHED          = BN_HILITE,
        BN_UNPUSHED        = BN_UNHILITE,
        BN_DBLCLK          = BN_DOUBLECLICKED,
        BN_SETFOCUS        = 6,
        BN_KILLFOCUS       = 7,
		BCN_FIRST = (-1250),
		BCN_HOTITEMCHANGE     = (BCN_FIRST + 0x0001),
		BCN_DROPDOWN          = (BCN_FIRST + 0x0002),
		NM_GETCUSTOMSPLITRECT = (BCN_FIRST + 0x0003)
	} ButtonNotifications;
	typedef enum ButtonStyles
	{
        BS_SPLITBUTTON          = 0x0000000C,
        BS_DEFSPLITBUTTON       = 0x0000000D,
        BS_COMMANDLINK          = 0x0000000E,
        BS_DEFCOMMANDLINK       = 0x0000000F,
        BS_PUSHBUTTON       = 0x00000000,
        BS_DEFPUSHBUTTON    = 0x00000001,
        BS_CHECKBOX         = 0x00000002,
        BS_AUTOCHECKBOX     = 0x00000003,
        BS_RADIOBUTTON      = 0x00000004,
        BS_3STATE           = 0x00000005,
        BS_AUTO3STATE       = 0x00000006,
        BS_GROUPBOX         = 0x00000007,
        BS_USERBUTTON       = 0x00000008,
        BS_AUTORADIOBUTTON  = 0x00000009,
        BS_PUSHBOX          = 0x0000000A,
        BS_OWNERDRAW        = 0x0000000B,
        BS_TYPEMASK         = 0x0000000F,
        BS_LEFTTEXT         = 0x00000020,
        BS_TEXT             = 0x00000000,
        BS_ICON             = 0x00000040,
        BS_BITMAP           = 0x00000080,
        BS_LEFT             = 0x00000100,
        BS_RIGHT            = 0x00000200,
        BS_CENTER           = 0x00000300,
        BS_TOP              = 0x00000400,
        BS_BOTTOM           = 0x00000800,
        BS_VCENTER          = 0x00000C00,
        BS_PUSHLIKE         = 0x00001000,
        BS_MULTILINE        = 0x00002000,
        BS_NOTIFY           = 0x00004000,
        BS_FLAT             = 0x00008000,
        BS_RIGHTBUTTON      = 0x00000020
	} ButtonStyles;
	typedef enum BUTTON_IMAGELIST_ALIGN 
	{
		BUTTON_IMAGELIST_ALIGN_LEFT    = 0,
		BUTTON_IMAGELIST_ALIGN_RIGHT   = 1,
		BUTTON_IMAGELIST_ALIGN_TOP     = 2,
		BUTTON_IMAGELIST_ALIGN_BOTTOM  = 3,
		BUTTON_IMAGELIST_ALIGN_CENTER  = 4       // Doesn't draw text
	} BUTTON_IMAGELIST_ALIGN;
	typedef struct BUTTON_IMAGELIST
	{
		LONG        himl;   // Images: Normal, Hot, Pushed, Disabled. If count is less than 4, we use index 1
		RECT        margin; // Margin around icon.
		BUTTON_IMAGELIST_ALIGN        uAlign;
	} BUTTON_IMAGELIST;
	typedef struct NMBCHOTITEM
	{
		NMHDR   hdr;
		LONG    dwFlags;           // HICF_*
	} NMBCHOTITEM;
	typedef struct BUTTON_SPLITINFO
	{
		LONG        mask;
		LONG  himlGlyph;         // interpreted as WCHAR if BCSIF_GLYPH is set
		LONG        uSplitStyle;
		SIZE        size;
	} BUTTON_SPLITINFO;
	typedef struct NMBCDROPDOWN
	{
		NMHDR   hdr;
		RECT    rcButton;
	} NMBCDROPDOWN;

	typedef enum ButtonMessages
	{
        BM_GETCHECK       = 0x00F0,
        BM_SETCHECK       = 0x00F1,
        BM_GETSTATE       = 0x00F2,
        BM_SETSTATE       = 0x00F3,
        BM_SETSTYLE       = 0x00F4,
        BM_CLICK          = 0x00F5,
        BM_GETIMAGE       = 0x00F6,
        BM_SETIMAGE       = 0x00F7,
        BM_SETDONTCLICK   = 0x00F8,
		BCM_FIRST      = 0x1600,
        BCM_GETIDEALSIZE        = (BCM_FIRST + 0x0001),
        BCM_SETIMAGELIST        = (BCM_FIRST + 0x0002),
        BCM_GETIMAGELIST        = (BCM_FIRST + 0x0003),
        BCM_SETTEXTMARGIN       = (BCM_FIRST + 0x0004),
        BCM_GETTEXTMARGIN       = (BCM_FIRST + 0x0005),
        BCM_SETDROPDOWNSTATE     = (BCM_FIRST + 0x0006),
        BCM_SETSPLITINFO         = (BCM_FIRST + 0x0007),
        BCM_GETSPLITINFO         = (BCM_FIRST + 0x0008),
        BCM_SETNOTE              = (BCM_FIRST + 0x0009),
        BCM_GETNOTE              = (BCM_FIRST + 0x000A),
        BCM_GETNOTELENGTH        = (BCM_FIRST + 0x000B),
        BCM_SETSHIELD            = (BCM_FIRST + 0x000C)
	} ButtonMessages;

 // IMAGELIST

    typedef enum ColorConstants {
        CLR_NONE = 0xFFFFFFFFL,
        CLR_DEFAULT = 0xFF000000L,
		CLR_HILIGHT = 0xFF000000L,
    } ColorConstants;
	typedef enum ImageList_StateFlags
	{
		ILS_NORMAL            = 0x00000000,
		ILS_GLOW              = 0x00000001,
		ILS_SHADOW            = 0x00000002,
		ILS_SATURATE          = 0x00000004,
		ILS_ALPHA             = 0x00000008,
	} ImageList_StateFlags;
    typedef enum ImageList_DrawFlags {
        ILD_NORMAL = 0x0000,
        ILD_TRANSPARENT = 0x0001,
        ILD_MASK = 0x0010,
        ILD_IMAGE = 0x0020,
        ILD_ROP = 0x0040,
        ILD_BLEND25 = 0x0002,
        ILD_BLEND50 = 0x0004,
        ILD_OVERLAYMASK = 0x0F00,
		ILD_PRESERVEALPHA     =  0x00001000, // This preserves the alpha channel in dest
		ILD_SCALE             =  0x00002000,// Causes the image to be scaled to cx, cy instead of clipped
		ILD_DPISCALE          =  0x00004000,
		ILD_ASYNC             =  0x00008000,
		ILD_SELECTED          =  0x00000004, //ILD_BLEND50
		ILD_FOCUS             =  0x00000002, //ILD_BLEND25
		ILD_BLEND             =  0x00000004, //ILD_BLEND50
	} ImageList_DrawFlags;

	typedef enum RASTEROPFLAGS {
		SRCAND 			= 0x8800C6,
		SRCCOPY 		= 0xCC0020,
		SRCINVERT 		= 0x660046,
		SRCPAINT 		= 0xEE0086,
		BLACKNESS 		= 0x42,
		CAPTUREBLT 		= 0x40000000,
		DSTINVERT 		= 0x550009,
		MERGECOPY 		= 0xC000CA,
		MERGEPAINT 		= 0xBB0226,
		NOMIRRORBITMAP 	= 0x80000000,
		NOTSRCCOPY 		= 0x330008,
		NOTSRCERASE 	= 0x1100A6,
		PATCOPY 		= 0xF00021,
		PATINVERT 		= 0x5A0049,
		PATPAINT 		= 0xFB0A09,
		SRCERASE 		= 0x440328,
		WHITENESS 		= 0xFF0062
	} RASTEROPFLAGS;

    typedef struct IMAGELISTDRAWPARAMS {
        LONG cbSize;
        LONG himl;
        LONG i;
        LONG hdcDst;
        LONG x;
        LONG y;
        LONG cx;
        LONG cy;
        [helpstring("x offest from the upperleft of bitmap")]
        LONG xBitmap;
        [helpstring("y offset from the upperleft of bitmap")]
        LONG yBitmap;
        LONG rgbBk;
        LONG rgbFg;
        ImageList_DrawFlags fStyle;
        RASTEROPFLAGS dwRop;
		ImageList_StateFlags fState;
		LONG       Frame;
		LONG       crEffect;
    } IMAGELISTDRAWPARAMS;

    typedef enum ImageList_Flags {
        ILC_MASK = 0x0001,
        ILC_COLOR = 0x0000,
        ILC_COLORDDB = 0x00FE,
        ILC_COLOR4 = 0x0004,
        ILC_COLOR8 = 0x0008,
        ILC_COLOR16 = 0x0010,
        ILC_COLOR24 = 0x0018,
        ILC_COLOR32 = 0x0020,
        ILC_PALETTE = 0x0800,
		ILC_MIRROR             = 0x00002000,      // Mirror the icons contained, if the process is mirrored
		ILC_PERITEMMIRROR      = 0x00008000,      // Causes the mirroring code to mirror each item when inserting a set of images, verses the whole strip
		ILC_ORIGINALSIZE       = 0x00010000,      // Imagelist should accept smaller than set images and apply OriginalSize based on image added
		ILC_HIGHQUALITYSCALE   = 0x00020000,      // Imagelist should enable use of the high quality scaler.
    } ImageList_Flags;



    typedef enum ImageList_CopyFlags {
        ILCF_MOVE = (0x00000000),
        ILCF_SWAP = (0x00000001),
    } ImageList_CopyFlags;

    typedef struct IMAGEINFO {
        LONG hbmImage;
        LONG hbmMask;
        LONG Unused1;
        LONG Unused2;
        RECT rcImage;
    } IMAGEINFO;

	typedef enum ILGT
	{
		ILGT_NORMAL            = 0x00000000,
		ILGT_ASYNC             = 0x00000001
	} ILGT;
	typedef enum ILP_Flags
	{
		ILP_NORMAL = 0,
		ILP_DOWNLEVEL = 1
	} ILP_Flags;

    [
        helpstring("ImageList control"),
        dllname("comctl32.dll")
    ]
    module ImageList {

        [entry("ImageList_Create")]
        LONG ImageList_Create(
                [in] LONG cx,
                [in] LONG cy,
                [in] ImageList_Flags flags,
                [in] LONG cInitial,
                [in] LONG cGrow);

        [entry("ImageList_Destroy")]
        BOOL ImageList_Destroy(
                [in] LONG himl);

        [entry("ImageList_GetImageCount")]
         LONG ImageList_GetImageCount(
                [in] LONG himl);

        [entry("ImageList_SetImageCount")]
        BOOL ImageList_SetImageCount(
                [in] LONG himl,
                [in] LONG uNewCount);

        [entry("ImageList_Add")]
        LONG ImageList_Add(
                [in] LONG himl,
                [in] LONG hbmImage,
                [in] LONG hbmMask);

        [entry("ImageList_ReplaceIcon")]
        LONG ImageList_ReplaceIcon(
                [in] LONG himl,
                [in] LONG i,
                [in] LONG hicon);

        [entry("ImageList_SetBkColor")]
         LONG ImageList_SetBkColor(
                [in] LONG himl,
                [in] LONG clrBk);

        [entry("ImageList_GetBkColor")]
        LONG ImageList_GetBkColor(
                [in] LONG himl);

        [entry("ImageList_SetOverlayImage")]
        BOOL ImageList_SetOverlayImage(
                [in] LONG himl,
                [in] LONG iImage,
                [in] LONG iOverlay);

        [entry("ImageList_Draw")]
         BOOL ImageList_Draw(
            [in] LONG himl,
            [in] LONG i,
            [in] LONG hdcDst,
            [in] LONG x,
            [in] LONG y,
            [in] ImageList_DrawFlags fStyle);

        [entry("ImageList_Replace")]
        BOOL ImageList_Replace(
            [in] LONG himl,
            [in] LONG i,
            [in] LONG hbmImage,
            [in] LONG hbmMask);

        [entry("ImageList_AddMasked")]
        LONG ImageList_AddMasked(
            [in] LONG himl,
            [in] LONG hbmImage,
            [in] LONG crMask);

        [entry("ImageList_DrawEx")]
        BOOL ImageList_DrawEx(
            [in] LONG himl,
            [in] LONG i,
            [in] LONG hdcDst,
            [in] LONG x,
            [in] LONG y,
            [in] LONG dx,
            [in] LONG dy,
            [in] LONG rgbBk,
            [in] LONG rgbFg,
            [in] ImageList_DrawFlags fStyle);

        [entry("ImageList_DrawIndirect")]
         BOOL ImageList_DrawIndirect(
            [in] IMAGELISTDRAWPARAMS* pimldp);

        [entry("ImageList_Remove")]
        BOOL ImageList_Remove(
            [in] LONG himl,
            [in] LONG i);

        [entry("ImageList_GetIcon")]
        LONG ImageList_GetIcon(
            [in] LONG himl,
            [in] LONG i,
            [in] LONG flags);

        [entry("ImageList_LoadImageA")]
        LONG ImageList_LoadImage(
            [in] LONG hInst,
            [in] void *lpBMPResource,
            [in] LONG cx,
            [in] LONG cGrow,
            [in] LONG crMask,
            [in] LONG uType,
            [in] LONG uFlags);

        [entry("ImageList_LoadImageW")]
        LONG ImageList_LoadImageW(
            [in] LONG hInst,
            [in] void *lpBMPResource,
            [in] LONG cx,
            [in] LONG cGrow,
            [in] LONG crMask,
            [in] LONG uType,
            [in] LONG uFlags);

        [entry("ImageList_Copy")]
        BOOL ImageList_Copy(
            [in] LONG himlDst,
            [in] LONG iDst,
            [in] LONG himlSrc,
            [in] LONG iSrc,
            [in] ImageList_CopyFlags uFlags);

        [entry("ImageList_BeginDrag")]
        BOOL ImageList_BeginDrag(
            [in] LONG himlTrack,
            [in] LONG iTrack,
            [in] LONG dxHotspot,
            [in] LONG dyHotspot);

        [entry("ImageList_EndDrag")]
         void ImageList_EndDrag();

        [entry("ImageList_DragEnter")]
        BOOL ImageList_DragEnter(
            [in] LONG hwndLock,
            [in] LONG x,
            [in] LONG y);

        [entry("ImageList_DragLeave")]
        BOOL ImageList_DragLeave(
            [in] LONG hwndLock);

        [entry("ImageList_DragMove")]
        BOOL ImageList_DragMove(
            [in] LONG x,
            [in] LONG y);

        [entry("ImageList_SetDragCursorImage")]
        BOOL ImageList_SetDragCursorImage(
            [in] LONG himlDrag,
            [in] LONG iDrag,
            [in] LONG dxHotspot,
            [in] LONG dyHotspot);

        [entry("ImageList_DragShowNolock")]
        BOOL ImageList_DragShowNolock(
            [in] BOOL fShow);

        [entry("ImageList_GetDragImage")]
        LONG ImageList_GetDragImage(
            [in] POINT *ppt,
            [in] POINT *pptHotspot);

        [entry("ImageList_Remove")]
        LONG ImageList_RemoveAll(LONG himl, [optional, defaultvalue(-1)] LONG i);

        [entry("ImageList_Read")]
        LONG ImageList_Read(
            [in] void *pstm);

        [entry("ImageList_Write")]
        BOOL ImageList_Write(
            [in] LONG himl,
            [in] void *pstm);

		[entry("ImageList_ReadEx")]
		LONG ImageList_ReadEx(
			[in] ILP_Flags dwFlags,
			[in] void *pstm,
			[in] UUID *riid,
			[out] LPVOID ppv);

		[entry("ImageList_WriteEx")]
		LONG ImageList_WriteEx(
			[in] LONG himl,
			[in] ILP_Flags dwFlags,
			[in] void *pstm);

        [entry("ImageList_GetIconSize")]
        BOOL ImageList_GetIconSize(
            [in] LONG himl,
            [out] LONG *cx,
            [out] LONG *cy);

        [entry("ImageList_SetIconSize")]
        BOOL ImageList_SetIconSize(
            [in] LONG himl,
            [in] LONG cx,
            [in] LONG cy);

        [entry("ImageList_GetImageInfo")]
        BOOL ImageList_GetImageInfo(
            [in] LONG himl,
            [in] LONG i,
            [out] IMAGEINFO *pImageInfo);

        [entry("ImageList_Merge")]
        LONG ImageList_Merge(
            [in] LONG himl1,
            [in] LONG i1,
            [in] LONG himl2,
            [in] LONG i2,
            [in] LONG dx,
            [in] LONG dy);

        [entry("ImageList_Duplicate")]
        LONG ImageList_Duplicate(
            [in] LONG himl);

		[entry("HIMAGELIST_QueryInterface")]
		LONG HIMAGELIST_QueryInterface(
			[in] LONG himl,
			[in] UUID *riid,
			[out] LPVOID ppv);
    }



 // = ===== HEADER CONTROL = ======================

    [
        helpstring("Header Control")
    ]
    module Header {

        const LPSTR WC_HEADER = "SysHeader32";
		const LONG HDIS_FOCUSED = 1;

    }

    typedef enum Header_Styles {
        HDS_HORZ = 0x0000,
        HDS_BUTTONS = 0x0002,
        HDS_HOTTRACK = 0x0004,
        HDS_HIDDEN = 0x0008,
        HDS_DRAGDROP = 0x0040,
        HDS_FULLDRAG = 0x0080,
        HDS_FILTERBAR = 0x0100,
		HDS_FLAT               = 0x0200,
		HDS_CHECKBOXES         = 0x0400,
		HDS_NOSIZING           = 0x0800,
		HDS_OVERFLOW           = 0x1000,
   } HeaderStyles;

    typedef enum HeaderFilterFlags {
        HDFT_ISSTRING = 0x0000, // HD_ITEM.pvFilter points to a HD_TEXTFILTER
        HDFT_ISNUMBER = 0x0001, // HD_ITEM.pvFilter points to a INT
		HDFT_ISDATE   = 0x0002,      // HD_ITEM.pvFilter points to a DWORD (dos date)
        HDFT_HASNOVALUE = 0x8000, // clear the filter, by setting this bit
    } HeaderFilterFlags;

    typedef struct HD_TEXTFILTER {
        LONG pszText; // [in] pointer to the buffer containing the filter (ANSI)
        LONG cchTextMax; // [in] max size of buffer/edit control buffer
    } HD_TEXTFILTER;

    typedef enum Header_ItemMask {
        HDI_WIDTH = 0x0001,
        HDI_HEIGHT = 0x0001,
        HDI_TEXT = 0x0002,
        HDI_FORMAT = 0x0004,
        HDI_LPARAM = 0x0008,
        HDI_BITMAP = 0x0010,
        HDI_IMAGE = 0x0020,
        HDI_DI_SETITEM = 0x0040,
        HDI_ORDER = 0x0080,
        HDI_FILTER = 0x0100,
		HDI_STATE = 0x0200,
    } HeaderItemMask;

    typedef enum Header_Formats {
        HDF_LEFT = 0,
        HDF_RIGHT = 1,
        HDF_CENTER = 2,
        HDF_JUSTIFYMASK = 3,
        HDF_RTLREADING = 4,
        HDF_BITMAP_ON_RIGHT = 0x1000,
        HDF_BITMAP = 0x2000,
        HDF_STRING = 0x4000,
        HDF_OWNERDRAW = 0x8000,
        HDF_IMAGE = 0x0800,
		HDF_SORTUP             = 0x0400,
		HDF_SORTDOWN           = 0x0200,
		HDF_CHECKBOX           = 0x0040,
		HDF_CHECKED            = 0x0080,
		HDF_FIXEDWIDTH         = 0x0100, // Can't resize the column; same as LVCFMT_FIXED_WIDTH
		HDF_SPLITBUTTON        = 0x1000000, // Column is a split button; same as LVCFMT_SPLITBUTTON
    } HeaderFormats;


    typedef struct HDITEM {
        HeaderItemMask    mask;
        LONG cxy;
        LONG pszText;
        LONG hbm;
        LONG cchTextMax;
        LONG fmt;
        LONG lParam;
        LONG iImage; // index of bitmap in ImageList
        LONG iOrder; // where to draw this item
        LONG type;
        LONG pvFilter;
		LONG state;
    } HDITEM;

    typedef enum Header_Messages {
        HDM_GETITEMCOUNT = (0x1200 + 0),
        HDM_INSERTITEMA = (0x1200 + 1),
        HDM_DELETEITEM = (0x1200 + 2),
        HDM_GETITEMA = (0x1200 + 3),
        HDM_SETITEMA = (0x1200 + 4),
        HDM_LAYOUT = (0x1200 + 5),
        HDM_HITTEST = (0x1200 + 6),
        HDM_GETITEMRECT = (0x1200 + 7),
        HDM_SETIMAGELIST = (0x1200 + 8),
        HDM_GETIMAGELIST = (0x1200 + 9),
        HDM_INSERTITEMW = (0x1200 + 10),
        HDM_GETITEMW = (0x1200 + 11),
        HDM_SETITEMW = (0x1200 + 12),
        HDM_ORDERTOINDEX = (0x1200 + 15),
        HDM_CREATEDRAGIMAGE = (0x1200 + 16),
        HDM_GETORDERARRAY = (0x1200 + 17),
        HDM_SETORDERARRAY = (0x1200 + 18),
        HDM_SETHOTDIVIDER = (0x1200 + 19),
        HDM_SETBITMAPMARGIN = (0x1200 + 20),
        HDM_GETBITMAPMARGIN = (0x1200 + 21),
        HDM_SETFILTERCHANGETIMEOUT = (0x1200+22),
        HDM_EDITFILTER = (0x1200+23),
        HDM_CLEARFILTER = (0x1200+24),
		HDM_GETITEMDROPDOWNRECT  = (0x1200+25),
		HDM_GETOVERFLOWRECT  = (0x1200+26),
		HDM_GETFOCUSEDITEM  = (0x1200+27),
		HDM_SETFOCUSEDITEM  = (0x1200+28),
    } HeaderMessages;

    typedef struct HDLAYOUT {
        LONG pRECT;
        LONG pWINDOWPOS;
    } HDLAYOUT;

    typedef enum Header_HitTestValues {
        HHT_NOWHERE = 0x0001,
        HHT_ONHEADER = 0x0002,
        HHT_ONDIVIDER = 0x0004,
        HHT_ONDIVOPEN = 0x0008,
        HHT_ONFILTER = 0x0010,
        HHT_ONFILTERBUTTON = 0x0020,
        HHT_ABOVE = 0x0100,
        HHT_BELOW = 0x0200,
        HHT_TORIGHT = 0x0400,
        HHT_TOLEFT = 0x0800,
		HHT_ONITEMSTATEICON    = 0x1000,
		HHT_ONDROPDOWN         = 0x2000,
		HHT_ONOVERFLOW         = 0x4000,
 
	} HeaderHitTestValues;

    typedef struct HDHITTESTINFO {
        POINT pt;
        HeaderHitTestValues flags;
        LONG iItem;
    } HDHITTESTINFO;

    typedef struct NMHEADER {
        NMHDR   hdr;
        LONG iItem;
        LONG iButton;
        LONG pHDITEM;
    }  NMHEADER;

    typedef enum Header_NotifyMessages {
        HDN_ITEMCHANGINGA = (-300),
        HDN_ITEMCHANGINGW = (-320),
        HDN_ITEMCHANGEDA = (-301),
        HDN_ITEMCHANGEDW = (-321),
        HDN_ITEMCLICKA = (-302),
        HDN_ITEMCLICKW = (-322),
        HDN_ITEMDBLCLICKA = (-303),
        HDN_ITEMDBLCLICKW = (-323),
        HDN_DIVIDERDBLCLICKA = (-305),
        HDN_DIVIDERDBLCLICKW = (-325),
        HDN_BEGINTRACKA = (-306),
        HDN_BEGINTRACKW = (-326),
        HDN_ENDTRACKA = (-307),
        HDN_ENDTRACKW = (-327),
        HDN_TRACKA = (-308),
        HDN_TRACKW = (-328),
        HDN_GETDISPINFOA = (-309),
        HDN_GETDISPINFOW = (-329),
        HDN_BEGINDRAG = (-310),
        HDN_ENDDRAG = (-311),
        HDN_FILTERCHANGE = (-312),
        HDN_FILTERBTNCLICK = (-313),
		HDN_BEGINFILTEREDIT = (-314),
		HDN_ENDFILTEREDIT = (-315),
		HDN_ITEMSTATEICONCLICK = (-316),
		HDN_ITEMKEYDOWN = (-317),
		HDN_DROPDOWN = (-318),
		HDN_OVERFLOWCLICK = (-319)
    } HeaderNotifyMessages;

    typedef struct NMHDDISPINFO {
        NMHDR hdr;
        LONG iItem;
        LONG mask;
        LONG pszText;
        LONG cchTextMax;
        LONG iImage;
        LONG lParam;
    } NMHDDISPINFO;

    typedef struct NMHDFILTERBTNCLICK {
        NMHDR hdr;
        LONG iItem;
        RECT rc;
    } NMHDFILTERBTNCLICK;

 // = = ====TOOLBAR CONTROL = = ====================================================

    typedef struct TBBUTTON {
        LONG iBitmap;
        LONG idCommand;
        BYTE fsState;
        BYTE fsStyle;
        BYTE bReserved[2];
        LONG dwData;
        LONG iString;
    } TBBUTTON;
    typedef struct TBBUTTON64 {
        LONG iBitmap;
        LONG idCommand;
        BYTE fsState;
        BYTE fsStyle;
        BYTE bReserved[6];
        LONG dwData;
        LONG iString;
    } TBBUTTON64;
    typedef struct COLORMAP {
        LONG from;
        LONG to;
    } COLORMAP;

    typedef enum Toolbar_ButtonStates {
        TBSTATE_CHECKED = 0x01,
        TBSTATE_PRESSED = 0x02,
        TBSTATE_ENABLED = 0x04,
        TBSTATE_HIDDEN = 0x08,
        TBSTATE_INDETERMINATE = 0x10,
        TBSTATE_WRAP = 0x20,
        TBSTATE_ELLIPSES = 0x40,
        TBSTATE_MARKED = 0x80,
    } ToolBarButtonStates;

    typedef enum ToolbarStyles {
        TBSTYLE_TOOLTIPS = 0x0100,
        TBSTYLE_WRAPABLE = 0x0200,
        TBSTYLE_ALTDRAG = 0x0400,
        TBSTYLE_FLAT = 0x0800,
        TBSTYLE_LIST = 0x1000,
        TBSTYLE_CUSTOMERASE = 0x2000,
        TBSTYLE_REGISTERDROP = 0x4000,
        TBSTYLE_TRANSPARENT = 0x8000,
        TBSTYLE_EX_DRAWDDARROWS = 0x00000001,
        TBSTYLE_EX_MIXEDBUTTONS = 0x00000008,
        TBSTYLE_EX_HIDECLIPPEDBUTTONS = 0x00000010, // don't show partially obscured buttons
		TBSTYLE_EX_MULTICOLUMN = 0x00000002, // conflicts w/ TBSTYLE_WRAPABLE
		TBSTYLE_EX_VERTICAL = 0x00000004,
		TBSTYLE_EX_DOUBLEBUFFER = 0x00000080, // Double Buffer the toolbar
    } ToolbarStyles;

    typedef enum ToolbarButtonStyles {
        BTNS_BUTTON = 0x0000,
        BTNS_SEP = 0x0001,
        BTNS_CHECK = 0x0002,
        BTNS_GROUP = 0x0004,
        BTNS_CHECKGROUP = (BTNS_GROUP | BTNS_CHECK),
        BTNS_DROPDOWN = 0x0008,
        BTNS_AUTOSIZE = 0x0010, // automatically calculate the cx of the button
        BTNS_NOPREFIX = 0x0020, // this button should not have accel prefix
        BTNS_SHOWTEXT = 0x0040, // ignored unless TBSTYLE_EX_MIXEDBUTTONS is set
        BTNS_WHOLEDROPDOWN = 0x0080, // draw drop-down arrow, but without split arrow section
    } ToolbarButtonStyles;

    typedef enum ToolbarCustomDrawReturnFlags {
        TBCDRF_NOEDGES = 0x00010000, // Don't draw button edges
        TBCDRF_HILITEHOTTRACK = 0x00020000, // Use color of the button bk when hottracked
        TBCDRF_NOOFFSET = 0x00040000, // Don't offset button if pressed
        TBCDRF_NOMARK = 0x00080000, // Don't draw default highlight of image/text for TBSTATE_MARKED
        TBCDRF_NOETCHEDEFFECT = 0x00100000, // Don't draw etched effect for disabled items
        TBCDRF_BLENDICON = 0x00200000, // Use ILD_BLEND50 on the icon image 
		TBCDRF_NOBACKGROUND = 0x00400000,  // Use ILD_BLEND50 on the icon image
		TBCDRF_USECDCOLORS  = 0x00800000,  // Use CustomDrawColors to RenderText regardless of VisualStyle
    } ToolbarCustomDrawReturnFlags;

    typedef enum CreateMappedBitmapFlags {
        CMB_MASKED = 0x02,
    } CreateMappedBitmapFlags;

    typedef struct NMTBCUSTOMDRAW {
        NMCUSTOMDRAW nmcd;
        LONG hbrMonoDither;
        [helpstring("Brush for drawing lines on buttons")]
        LONG hbrLines;
        [helpstring("Pen for drawing lines on buttons")]
        LONG hpenLines;
        LONG clrText; // Color of text
        LONG clrMark; // Color of text bk when marked. (only if TBSTATE_MARKED)
        LONG clrTextHighlight; // Color of text when highlighted
        LONG clrBtnFace; // Background of the button
        LONG clrBtnHighlight; // 3D highlight
        LONG clrHighlightHotTrack; // In conjunction with fHighlightHotTrack
 // will cause button to highlight like a menu
        RECT rcText; // Rect for text
        LONG nStringBkMode;
        LONG nHLStringBkMode;
		LONG iListGap;
    } NMTBCUSTOMDRAW;

    typedef enum Toolbar_Messages {
        TB_ENABLEBUTTON = (0x400 + 1),
        TB_CHECKBUTTON = (0x400 + 2),
        TB_PRESSBUTTON = (0x400 + 3),
        TB_HIDEBUTTON = (0x400 + 4),
        TB_INDETERMINATE = (0x400 + 5),
        TB_MARKBUTTON = (0x400 + 6),
        TB_ISBUTTONENABLED = (0x400 + 9),
        TB_ISBUTTONCHECKED = (0x400 + 10),
        TB_ISBUTTONPRESSED = (0x400 + 11),
        TB_ISBUTTONHIDDEN = (0x400 + 12),
        TB_ISBUTTONINDETERMINATE = (0x400 + 13),
        TB_ISBUTTONHIGHLIGHTED = (0x400 + 14),
        TB_SETSTATE = (0x400 + 17),
        TB_GETSTATE = (0x400 + 18),
        TB_ADDBITMAP = (0x400 + 19),
        TB_ADDBUTTONS = (0x400 + 20),
        TB_INSERTBUTTON = (0x400 + 21),
        TB_DELETEBUTTON = (0x400 + 22),
        TB_GETBUTTON = (0x400 + 23),
        TB_BUTTONCOUNT = (0x400 + 24),
        TB_COMMANDTOINDEX = (0x400 + 25),
        TB_SAVERESTORE = (0x400 + 26),
        TB_SAVERESTOREW = (0x400 + 76),
        TB_CUSTOMIZE = (0x400 + 27),
        TB_ADDSTRINGA = (0x400 + 28),
        TB_ADDSTRINGW = (0x400 + 77),
        TB_GETITEMRECT = (0x400 + 29),
        TB_BUTTONSTRUCTSIZE = (0x400 + 30),
        TB_SETBUTTONSIZE = (0x400 + 31),
        TB_SETBITMAPSIZE = (0x400 + 32),
        TB_AUTOSIZE = (0x400 + 33),
        TB_GETTOOLTIPS = (0x400 + 35),
        TB_SETTOOLTIPS = (0x400 + 36),
        TB_SETPARENT = (0x400 + 37),
        TB_SETROWS = (0x400 + 39),
        TB_GETROWS = (0x400 + 40),
        TB_SETCMDID = (0x400 + 42),
        TB_CHANGEBITMAP = (0x400 + 43),
        TB_GETBITMAP = (0x400 + 44),
        TB_GETBUTTONTEXT = (0x400 + 45),
        TB_GETBUTTONTEXTW = (0x400 + 75),
        TB_REPLACEBITMAP = (0x400 + 46),
        TB_SETINDENT = (0x400 + 47),
        TB_SETIMAGELIST = (0x400 + 48),
        TB_GETIMAGELIST = (0x400 + 49),
        TB_LOADIMAGES = (0x400 + 50),
        TB_GETRECT = (0x400 + 51), // wParam is the Cmd instead of index
        TB_SETHOTIMAGELIST = (0x400 + 52),
        TB_GETHOTIMAGELIST = (0x400 + 53),
        TB_SETDISABLEDIMAGELIST = (0x400 + 54),
        TB_GETDISABLEDIMAGELIST = (0x400 + 55),
        TB_SETSTYLE = (0x400 + 56),
        TB_GETSTYLE = (0x400 + 57),
        TB_GETBUTTONSIZE = (0x400 + 58),
        TB_SETBUTTONWIDTH = (0x400 + 59),
        TB_SETMAXTEXTROWS = (0x400 + 60),
        TB_GETTEXTROWS = (0x400 + 61),
        TB_SETCOLORSCHEME = 0x2002, // lParam is color scheme
        TB_GETOBJECT = (0x400 + 62), // wParam = = IID, lParam void **ppv
        TB_GETHOTITEM = (0x400 + 71),
        TB_SETHOTITEM = (0x400 + 72), // wParam = = iHotItem
        TB_SETANCHORHIGHLIGHT = (0x400 + 73), // wParam = = TRUE/FALSE
        TB_GETANCHORHIGHLIGHT = (0x400 + 74),
        TB_MAPACCELERATOR = (0x400 + 78), // wParam = = ch, lParam LONG * pidBtn
        TB_GETINSERTMARK = (0x400 + 79), // lParam = = LPTBINSERTMARK
        TB_SETINSERTMARK = (0x400 + 80), // lParam = = LPTBINSERTMARK
        TB_INSERTMARKHITTEST = (0x400 + 81), // wParam = = LPPOINT lParam = = LPTBINSERTMARK
        TB_MOVEBUTTON = (0x400 + 82),
        TB_GETMAXSIZE = (0x400 + 83), // lParam = = LPSIZE
        TB_SETEXTENDEDSTYLE = (0x400 + 84), // For TBSTYLE_EX_*
        TB_GETEXTENDEDSTYLE = (0x400 + 85), // For TBSTYLE_EX_*
        TB_GETBITMAPFLAGS = (0x400 + 41),
        TB_GETBUTTONINFOW = (0x400 + 63),
        TB_SETBUTTONINFOW = (0x400 + 64),
        TB_GETBUTTONINFO = (0x400 + 65),
        TB_SETBUTTONINFO = (0x400 + 66),
        TB_INSERTBUTTONW = (0x400 + 67),
        TB_ADDBUTTONSW = (0x400 + 68),
        TB_HITTEST = (0x400 + 69),
        TB_SETDRAWTEXTFLAGS = (0x400 + 70), // wParam = = mask lParam = = bit values
        TB_GETPADDING = (0x400 + 86),
        TB_SETPADDING = (0x400 + 87),
        TB_SETINSERTMARKCOLOR = (0x400 + 88),
        TB_GETINSERTMARKCOLOR = (0x400 + 89),
        TB_MAPACCELERATORW = (0x400 + 90), // wParam = = ch, lParam int * pidBtn
		TB_GETSTRINGW           = (0x400 + 91),
		TB_GETSTRINGA           = (0x400 + 92),
		TB_SETBOUNDINGSIZE      = (0x400 + 93),
		TB_SETHOTITEM2          = (0x400 + 94),  // wParam == iHotItem,  lParam = dwFlags
		TB_HASACCELERATOR       = (0x400 + 95),  // wParam == char, lParam = &iCount
		TB_SETLISTGAP           = (0x400 + 96),
		TB_GETIMAGELISTCOUNT    = (0x400 + 98),
		TB_GETIDEALSIZE         = (0x400 + 99),
		TB_TRANSLATEACCELERATOR = (0x400 + 97), //   CCM_TRANSLATEACCELERATOR
		TB_GETMETRICS           = (0x400 + 101),
		TB_SETMETRICS           = (0x400 + 102),
		TB_GETITEMDROPDOWNRECT  = (0x400 + 103),  // Rect of item's drop down button
		TB_SETPRESSEDIMAGELIST  = (0x400 + 104),
		TB_GETPRESSEDIMAGELIST  = (0x400 + 105),

	} ToolbarMessages;

    typedef enum Toolbar_InsertMarkFlags {
        TBIMHT_AFTER = 0x00000001, // TRUE = insert After iButton, otherwise before
        TBIMHT_BACKGROUND = 0x00000002, // TRUE iff missed buttons completely
    } ToolbarInsertMarkFlags;

    typedef struct TBADDBITMAP {
        LONG hInst;
        LONG nID;
    } TBADDBITMAP;

    typedef enum Toolbar_AddBitmapValues {
        HINST_COMMCTRL = (-1),
        IDB_STD_SMALL_COLOR = 0,
        IDB_STD_LARGE_COLOR = 1,
        IDB_VIEW_SMALL_COLOR = 4,
        IDB_VIEW_LARGE_COLOR = 5,
        IDB_HIST_SMALL_COLOR = 8,
        IDB_HIST_LARGE_COLOR = 9,
		IDB_HIST_NORMAL      = 12,
		IDB_HIST_HOT         = 13,
		IDB_HIST_DISABLED    = 14,
		IDB_HIST_PRESSED     = 15,
    } ToolbarAddBitmapValues;

 // icon indexes for standard bitmap
    typedef enum Toolbar_StandardBitmaps {
        STD_CUT = 0,
        STD_COPY = 1,
        STD_PASTE = 2,
        STD_UNDO = 3,
        STD_REDOW = 4,
        STD_DELETE = 5,
        STD_FILENEW = 6,
        STD_FILEOPEN = 7,
        STD_FILESAVE = 8,
        STD_PRINTPRE = 9,
        STD_PROPERTIES = 10,
        STD_HELP = 11,
        STD_FIND = 12,
        STD_REPLACE = 13,
        STD_PRINT = 14,
        VIEW_LARGEICONS = 0,
        VIEW_SMALLICONS = 1,
        VIEW_LIST = 2,
        VIEW_DETAILS = 3,
        VIEW_SORTNAME = 4,
        VIEW_SORTSIZE = 5,
        VIEW_SORTDATE = 6,
        VIEW_SORTTYPE = 7,
        VIEW_PARENTFOLDER = 8,
        VIEW_NETCONNECT = 9,
        VIEW_NETDISCONNECT = 10,
        VIEW_NEWFOLDER = 11,
        VIEW_VIEWMENU = 12,
        HIST_BACK = 0,
        HIST_FORWARD = 1,
        HIST_FAVORITES = 2,
        HIST_ADDTOFAVORITES = 3,
        HIST_VIEWTREE = 4,
    } ToolbarStandardBitmaps;

    typedef struct TBSAVEPARAMS {
        LONG hkr;
        LONG pszSubKey;
        LONG pszValueName;
    } TBSAVEPARAMS;

    typedef struct TBINSERTMARK {
        LONG iButton;
        LONG dwFlags;
    } TBINSERTMARK;

    typedef struct TBREPLACEBITMAP {
        LONG hInstOld;
        LONG nIDOld;
        LONG hInstNew;
        LONG nIDNew;
        LONG nButtons;
    } TBREPLACEBITMAP;

    typedef enum Toolbar_BitmapFlags {
        TBBF_LARGE = 0x0001,
    } ToolbarBitmapFlags;

    typedef enum Toolbar_ButtonInfoMask {
        TBIF_IMAGE = 0x00000001,
        TBIF_TEXT = 0x00000002,
        TBIF_STATE = 0x00000004,
        TBIF_STYLE = 0x00000008,
        TBIF_LPARAM = 0x00000010,
        TBIF_COMMAND = 0x00000020,
        TBIF_SIZE = 0x00000040,
		TBIF_BYINDEX = 0x80000000,
    } ToolbarButtonInfoMask;

    typedef struct TBBUTTONINFO {
        LONG cbSize;
        LONG dwMask;
        LONG idCommand;
        LONG iImage;
        BYTE fsState;
        BYTE fsStyle;
        short cx;
        LONG lParam;
        LONG pszText;
        LONG cchText;
    } TBBUTTONINFO;

 // Hot item change flags
    typedef enum Toolbar_HotItemFlags {
        HICF_OTHER = 0x00000000,
        HICF_MOUSE = 0x00000001, // Triggered by mouse
        HICF_ARROWKEYS = 0x00000002, // Triggered by arrow keys
        HICF_ACCELERATOR = 0x00000004, // Triggered by accelerator
        HICF_DROPDOWN = 0x00000008, // Button dropped down
        HICF_ENTERING = 0x00000010, // idOld is invalid
        HICF_LEAVING = 0x00000020, // idNew is invalid
        HICF_RESELECT = 0x00000040, // hot item reselected
        HICF_LMOUSE = 0x00000080, // left mouse button selected
        HICF_TOGGLEDROPDOWN = 0x00000100, // Toggle button's dropdown state
    } Toolbar_HotItemFlags;

    typedef struct NMTBHOTITEM {
        NMHDR   hdr;
        LONG idOld;
        LONG idNew;
        Toolbar_HotItemFlags dwFlags;
    } NMTBHOTITEM;

    typedef struct NMTBDISPINFO {
        NMHDR  hdr;
        LONG dwMask; // [in] Specifies the values requested .[out] Client ask the data to be set for future use
        LONG idCommand; // [in] id of button we're requesting info for
        LONG lParam; // [in] lParam of button
        LONG iImage; // [out] image index
        LONG pszText; // [out] new text for item
        LONG cchText; // [in] size of buffer pointed to by pszText
    } NMTBDISPINFO;

    typedef enum Toolbar_NotifyCodes {
        TBN_GETBUTTONINFO = (-700-0),
        TBN_GETBUTTONINFOW = (-700-20),
        TBN_BEGINDRAG = (-700-1),
        TBN_ENDDRAG = (-700-2),
        TBN_BEGINADJUST = (-700-3),
        TBN_ENDADJUST = (-700-4),
        TBN_RESET = (-700-5),
        TBN_QUERYINSERT = (-700-6),
        TBN_QUERYDELETE = (-700-7),
        TBN_TOOLBARCHANGE = (-700-8),
        TBN_CUSTHELP = (-700-9),
        TBN_DROPDOWN = (-700 - 10),
        TBN_GETOBJECT = (-700 - 12),
        TBN_HOTITEMCHANGE = (-700 - 13),
        TBN_DRAGOUT = (-700 - 14), // this is sent when the user clicks down on a button then drags off the button
        TBN_DELETINGBUTTON = (-700 - 15), // uses TBNOTIFY
        TBN_GETDISPINFO = (-700 - 16), // This is sent when the  toolbar needs  some display information
        TBN_GETDISPINFOW = (-700 - 17), // This is sent when the  toolbar needs  some display information
        TBN_GETINFOTIP = (-700 - 18),
        TBN_GETINFOTIPW = (-700 - 19),
        TBN_RESTORE = (-700 - 21),
        TBN_SAVE = (-700 - 22),
        TBN_INITCUSTOMIZE = (-700 - 23),
		TBN_WRAPHOTITEM   = (-700 - 24),
		TBN_DUPACCELERATOR = (-700 - 25),
		TBN_WRAPACCELERATOR = (-700 - 26),
		TBN_DRAGOVER        = (-700 - 27),
		TBN_MAPACCELERATOR  = (-700 - 28),

    } ToolbarNotifyCodes;

	typedef enum TBM_Mask
	{
		TBMF_PAD               = 0x00000001,
		TBMF_BARPAD            = 0x00000002,
		TBMF_BUTTONSPACING     = 0x00000004,
	} TBM_Mask;

	typedef struct TBMETRICS {
		LONG cbSize;
		TBM_Mask dwMask;

		int cxPad;        // PAD
		int cyPad;
		int cxBarPad;     // BARPAD
		int cyBarPad;
		int cxButtonSpacing;   // BUTTONSPACING
		int cyButtonSpacing;
	} TBMETRICS;

    typedef enum ToolbarCustomizeReturnFlags {
        TBNRF_HIDEHELP = 0x00000001,
        TBNRF_ENDCUSTOMIZE = 0x00000002,
    } ToolbarCustomizeReturnFlags;

    typedef enum Toolbar_NotifyFlags {
        TBNF_IMAGE = 0x00000001,
        TBNF_TEXT = 0x00000002,
        TBNF_DI_SETITEM = 0x10000000,
    } Toolbar_NotifyFlags;

    typedef struct NMTBSAVE {
        NMHDR hdr;
        LONG pData;
        LONG pCurrent;
        LONG cbData;
        LONG iItem;
        LONG cButtons;
        TBBUTTON tbButton;
    } NMTBSAVE;

    typedef struct NMTBRESTORE {
        NMHDR hdr;
        LONG pData;
        LONG pCurrent;
        LONG cbData;
        LONG iItem;
        LONG cButtons;
        LONG cbBytesPerRecord;
        TBBUTTON tbButton;
    } NMTBRESTORE;

    typedef struct NMTBGETINFOTIP {
        NMHDR hdr;
        LONG pszText;
        LONG cchTextMax;
        LONG iItem;
        LONG lParam;
    } NMTBGETINFOTIP;

    typedef enum ToolbarDropdownReturnValues {
        TBDDRET_DEFAULT = 0,
        TBDDRET_NODEFAULT = 1,
        TBDDRET_TREATPRESSED = 2, // Treat as a standard press button
    } ToolbarDropdownReturnValues;

    typedef struct NMTOOLBAR {
        NMHDR hdr;
        LONG iItem;
        TBBUTTON tbButton;
        LONG cchText;
        LONG pszText;
    } NMTOOLBAR;

    [
        helpstring("Toolbar Control"),
        dllname("comctl32.dll")
    ]
    module ToolBar {

        const LPSTR TOOLBARCLASSNAME = "ToolbarWindow32";

        [entry("CreateToolbarEx")]
        LONG CreateToolbarEx(
            [in] LONG hwnd,
            [in] LONG ws,
            [in] LONG wID,
            [in] LONG nBitmaps,
            [in] LONG hBMInst,
            [in] LONG wBMID,
            [in] TBBUTTON *lpButtonsArray,
            [in] LONG iNumButtons,
            [in] LONG dxButton,
            [in] LONG dyButton,
            [in] LONG dxBitmap,
            [in] LONG dyBitmap,
            [in] LONG uStructSize);

        [entry("CreateMappedBitmap")]
         LONG CreateMappedBitmap(
            [in] LONG hInstance,
            [in] LONG idBitmap,
            [in] LONG wFlags,
            [in] COLORMAP *lpColorMapArray,
            [in] LONG iNumMaps);

     } // ENDTOOLBAR

 // = = ====REBAR CONTROL = = ======================================================

    [
        helpstring("ReBar Control"),
        dllname("comctl32.dll")
    ]
    module ReBar {

        const LPSTR REBARCLASSNAME = "ReBarWindow32";
    }

    typedef enum ReBar_IM {
        RBIM_IMAGELIST = 0x00000001,
    } ReBar_IM;

    typedef enum ReBar_Styles {
        RBS_TOOLTIPS = 0x0100,
        RBS_VARHEIGHT = 0x0200,
        RBS_BANDBORDERS = 0x0400,
        RBS_FIXEDORDER = 0x0800,
        RBS_REGISTERDROP = 0x1000,
        RBS_AUTOSIZE = 0x2000,
        RBS_VERTICALGRIPPER = 0x4000, // this always has the vertical gripper (default for horizontal mode)
        RBS_DBLCLKTOGGLE = 0x8000,
    } ReBar_Styles;

    typedef struct REBARINFO {
        LONG cbSize;
        LONG fMask;
        LONG himl;
    } REBARINFO;

    typedef enum ReBar_BandStyles {
        RBBS_BREAK = 0x00000001, // break to new line
        RBBS_FIXEDSIZE = 0x00000002, // band can't be sized
        RBBS_CHILDEDGE = 0x00000004, // edge around top & bottom of child window
        RBBS_HIDDEN = 0x00000008, // don't show
        RBBS_NOVERT = 0x00000010, // don't show when vertical
        RBBS_FIXEDBMP = 0x00000020, // bitmap doesn't move during band resize
        RBBS_VARIABLEHEIGHT = 0x00000040, // allow autosizing of this child vertically
        RBBS_GRIPPERALWAYS = 0x00000080, // always show the gripper
        RBBS_NOGRIPPER = 0x00000100, // never show the gripper
        RBBS_USECHEVRON = 0x00000200,
        RBBS_HIDETITLE = 0x00000400,
		RBBS_TOPALIGN  = 0x00000800,
    } ReBarBandStyles;

    typedef enum ReBar_BandInfoMask {
        RBBIM_STYLE = 0x00000001,
        RBBIM_COLORS = 0x00000002,
        RBBIM_TEXT = 0x00000004,
        RBBIM_IMAGE = 0x00000008,
        RBBIM_CHILD = 0x00000010,
        RBBIM_CHILDSIZE = 0x00000020,
        RBBIM_SIZE = 0x00000040,
        RBBIM_BACKGROUND = 0x00000080,
        RBBIM_ID = 0x00000100,
        RBBIM_IDEALSIZE = 0x00000200,
        RBBIM_LPARAM = 0x00000400,
        RBBIM_HEADERSIZE = 0x00000800, // control the size of the header
		RBBIM_CHEVRONLOCATION = 0x00001000,
		RBBIM_CHEVRONSTATE    = 0x00002000,
    } ReBarBandInfoMask;

    typedef struct REBARBANDINFO {
        LONG cbSize;
        ReBarBandInfoMask    fMask;
        LONG fStyle;
        LONG clrFore;
        LONG clrBack;
        LONG lpText;
        LONG cch;
        LONG iImage;
        LONG hwndChild;
        LONG cxMinChild;
        LONG cyMinChild;
        LONG cx;
        LONG hbmBack;
        LONG wID;
        LONG cyChild;
        LONG cyMaxChild;
        LONG cyIntegral;
        LONG cxIdeal;
        LONG lParam;
        LONG cxHeader;
        RECT rcChevronLocation;  // the rect is in client co-ord wrt hwndChild
        LONG uChevronState;      // STATE_SYSTEM_*
   } REBARBANDINFO;

    typedef enum ReBar_Messages {
        RB_INSERTBANDA = (0x400 +  1),
        RB_DELETEBAND = (0x400 +  2),
        RB_GETBARINFO = (0x400 +  3),
        RB_SETBARINFO = (0x400 +  4),
        RB_GETBANDINFO = (0x400 +  5),
        RB_SETBANDINFOA = (0x400 +  6),
        RB_SETPARENT = (0x400 +  7),
        RB_HITTEST = (0x400 +  8),
        RB_GETRECT = (0x400 +  9),
        RB_INSERTBANDW = (0x400 +  10),
        RB_SETBANDINFOW = (0x400 +  11),
        RB_GETBANDCOUNT = (0x400 +  12),
        RB_GETROWCOUNT = (0x400 +  13),
        RB_GETROWHEIGHT = (0x400 +  14),
        RB_IDTOINDEX = (0x400 +  16), // wParam = = id
        RB_GETTOOLTIPS = (0x400 +  17),
        RB_SETTOOLTIPS = (0x400 +  18),
        RB_SETBKCOLOR = (0x400 +  19), // sets the default BK color
        RB_GETBKCOLOR = (0x400 +  20), // defaults to CLR_NONE
        RB_SETTEXTCOLOR = (0x400 +  21),
        RB_GETTEXTCOLOR = (0x400 +  22), // defaults to 0x00000000
        RB_SIZETORECT = (0x400 +  23), // resize the rebar/break bands and such to this rect (lparam)
        RB_SETCOLORSCHEME = CCM_SETCOLORSCHEME , // lParama is color scheme
        RB_BEGINDRAG = (0x400 + 24),
        RB_ENDDRAG = (0x400 + 25),
        RB_DRAGMOVE = (0x400 + 26),
        RB_GETBARHEIGHT = (0x400 + 27),
        RB_GETBANDINFOW = (0x400 + 28),
        RB_GETBANDINFOA = (0x400 + 29),
        RB_MINIMIZEBAND = (0x400 + 30),
        RB_MAXIMIZEBAND = (0x400 + 31),
        RB_GETDROPTARGET = 0x2004, //(0x400 + 32)??? but SDK says ==CCM_GETDROPTARGET
        RB_GETBANDBORDERS = (0x400 + 34), // returns in lparam = lprc the amount of edges added to band wparam
        RB_SHOWBAND = (0x400 + 35), // show/hide band
        RB_SETPALETTE = (0x400 + 37),
        RB_GETPALETTE = (0x400 + 38),
        RB_MOVEBAND = (0x400 + 39),
		RB_GETBANDMARGINS   = (0x400 + 40),
		RB_SETEXTENDEDSTYLE = (0x400 + 41),
		RB_GETEXTENDEDSTYLE = (0x400 + 42),
        RB_PUSHCHEVRON = (0x400 + 43),
		RB_SETBANDWIDTH     = (0x400 + 44),
    } ReBarMessages;
	typedef enum ReBar_SizeToRect_Flags
	{
		RBSTR_CHANGERECT = 0x0001,
	} ReBar_SizeToRect_Flags;

    typedef enum ReBar_NotificationCodes {
        RBN_HEIGHTCHANGE = (-831 - 0),
        RBN_GETOBJECT = (-831 - 1),
        RBN_LAYOUTCHANGED = (-831 - 2),
        RBN_AUTOSIZE = (-831 - 3),
        RBN_BEGINDRAG = (-831 - 4),
        RBN_ENDDRAG = (-831 - 5),
        RBN_DELETINGBAND = (-831 - 6), // Uses NMREBAR
        RBN_DELETEDBAND = (-831 - 7), // Uses NMREBAR
        RBN_CHILDSIZE = (-831 - 8),
        RBN_CHEVRONPUSHED = (-831 - 10),
		RBN_SPLITTERDRAG  = (-831 - 11),
        RBN_MINMAX = (-831 - 21),
		RBN_AUTOBREAK = (-831 - 22),
    } ReBar_NotificationCodes;

    typedef struct NMREBARCHILDSIZE {
        NMHDR hdr;
        LONG uBand;
        LONG wID;
        RECT rcChild;
        RECT rcBand;
    } NMREBARCHILDSIZE;

    typedef enum NMREBARMasks {
        RBNM_ID = 0x00000001,
        RBNM_STYLE = 0x00000002,
        RBNM_LPARAM = 0x00000004,
    } NMREBARMasks;

    typedef struct NMREBAR {
        NMHDR   hdr;
        NMREBARMasks dwMask; // RBNM_*
        LONG uBand;
        LONG fStyle;
        LONG wID;
        LONG lParam;
    } NMREBAR;

    typedef struct NMRBAUTOSIZE {
        NMHDR hdr;
        BOOL fChanged;
        RECT rcTarget;
        RECT rcActual;
    } NMRBAUTOSIZE;

    typedef struct NMREBARCHEVRON {
        NMHDR hdr;
        LONG uBand;
        LONG wID;
        LONG lParam;
        RECT rc;
        LONG lParamNM;
    } NMREBARCHEVRON;

    typedef enum ReBar_HitTestFlags {
        RBHT_NOWHERE = 0x0001,
        RBHT_CAPTION = 0x0002,
        RBHT_CLIENT = 0x0003,
        RBHT_GRABBER = 0x0004,
        RBHT_CHEVRON = 0x0008,
		RBHT_SPLITTER = 0x0010,
    } ReBarHitTestFlags;

    typedef struct RBHITTESTINFO {
        POINT pt;
            ReBarHitTestFlags flags;
        LONG iBand;
    } RBHITTESTINFO;

typedef struct NMREBARSPLITTER
{
    NMHDR hdr;
    RECT  rcSizing;
} NMREBARSPLITTER;

typedef enum RBAB
{
	RBAB_AUTOSIZE = 0x0001,
	RBAB_ADDBAND  = 0x0002,
} RBAB;
typedef struct NMREBARAUTOBREAK
{
    NMHDR hdr;
    LONG uBand;
    LONG wID;
    LONG lParam;
    LONG uMsg;
    LONG fStyleCurrent;
    BOOL fAutoBreak;
} NMREBARAUTOBREAK;



 // = = ====TOOLTIPS CONTROL = = ===================================================

    [
        helpstring("Tooltips control")
    ]
    module Tooltips {

        const LPSTR TOOLTIPS_CLASS = "tooltips_class32";
    }

    typedef struct TTTOOLINFO {
        LONG cbSize;
        LONG uFlags;
        LONG hwnd;
        LONG uId;
        RECT rect;
        LONG hinst;
        LONG lpszText;
        LONG lParam;
		LONG lpReserved;
    } TTTOOLINFO;

    typedef enum Tooltip_Styles {
        TTS_ALWAYSTIP = 0x01,
        TTS_NOPREFIX = 0x02,
        TTS_NOANIMATE = 0x10,
        TTS_NOFADE = 0x20,
        TTS_BALLOON = 0x40,
		TTS_CLOSE = 0x80,
		TTS_USEVISUALSTYLE = 0x100,
    } Tooltip_Styles;


    typedef enum Tooltip_Flags {
        TTF_IDISHWND = 0x0001,

// Use this to center around trackpoint in trackmode
// -OR- to center around tool in normal mode.
// Use TTF_ABSOLUTE to place the tip exactly at the track coords when
// in tracking mode.  TTF_ABSOLUTE can be used in conjunction with TTF_CENTERTIP
// to center the tip absolutely about the track point.

        TTF_CENTERTIP = 0x0002,
        TTF_RTLREADING = 0x0004,
        TTF_SUBCLASS = 0x0010,
        TTF_TRACK = 0x0020,
        TTF_ABSOLUTE = 0x0080,
        TTF_TRANSPARENT = 0x0100,
        TTF_DI_SETITEM = 0x8000, // valid only on the TTN_NEEDTEXT callback
    } Tooltip_Flags;

    typedef enum Tooltip_DelayTimeFlags {
        TTDT_AUTOMATIC = 0,
        TTDT_RESHOW = 1,
        TTDT_AUTOPOP = 2,
        TTDT_INITIAL = 3,
    } Tooltip_DelayTimeFlags;

    typedef enum Tooltip_Messages {
        TTM_ACTIVATE = (0x400 + 1),
        TTM_SETDELAYTIME = (0x400 + 3),
        TTM_ADDTOOL = (0x400 + 4),
        TTM_ADDTOOLW = (0x400 + 50),
        TTM_DELTOOL = (0x400 + 5),
        TTM_DELTOOLW = (0x400 + 51),
        TTM_NEWTOOLRECT = (0x400 + 6),
        TTM_NEWTOOLRECTW = (0x400 + 52),
        TTM_RELAYEVENT = (0x400 + 7),
        TTM_GETTOOLINFO = (0x400 + 8),
        TTM_GETTOOLINFOW = (0x400 + 53),
        TTM_SETTOOLINFO = (0x400 + 9),
        TTM_SETTOOLINFOW = (0x400 + 54),
        TTM_HITTEST = (0x400 +10),
        TTM_HITTESTW = (0x400 +55),
        TTM_GETTEXT = (0x400 +11),
        TTM_GETTEXTW = (0x400 +56),
        TTM_UPDATETIPTEXT = (0x400 +12),
        TTM_UPDATETIPTEXTW = (0x400 +57),
        TTM_GETTOOLCOUNT = (0x400 +13),
        TTM_ENUMTOOLS = (0x400 +14),
        TTM_ENUMTOOLSW = (0x400 +58),
        TTM_GETCURRENTTOOL = (0x400 + 15),
        TTM_GETCURRENTTOOLW = (0x400 + 59),
        TTM_WINDOWFROMPOINT = (0x400 + 16),
        TTM_TRACKACTIVATE = (0x400 + 17), // wParam = TRUE/FALSE start end  lparam = LPTOOLINFO
        TTM_TRACKPOSITION = (0x400 + 18), // lParam = dwPos
        TTM_SETTIPBKCOLOR = (0x400 + 19),
        TTM_SETTIPTEXTCOLOR = (0x400 + 20),
        TTM_GETDELAYTIME = (0x400 + 21),
        TTM_GETTIPBKCOLOR = (0x400 + 22),
        TTM_GETTIPTEXTCOLOR = (0x400 + 23),
        TTM_SETMAXTIPWIDTH = (0x400 + 24),
        TTM_GETMAXTIPWIDTH = (0x400 + 25),
        TTM_SETMARGIN = (0x400 + 26), // lParam = lprc
        TTM_GETMARGIN = (0x400 + 27), // lParam = lprc
        TTM_POP = (0x400 + 28),
        TTM_UPDATE = (0x400 + 29),
        TTM_GETBUBBLESIZE = (0x400 + 30),
        TTM_ADJUSTRECT = (0x400 + 31),
        TTM_SETTITLE = (0x400 + 32), // wParam = TTI_*, lParam = char* szTitle
        TTM_SETTITLEW = (0x400 + 33), // wParam = TTI_*, lParam = wchar* szTitle
        TTM_POPUP = (0x400 + 34), 
        TTM_GETTITLE = (0x400 + 35), // wParam = 0, lParam = TTGETTITLE*
		TTM_SETWINDOWTHEME = CCM_SETWINDOWTHEME, //==CCM_SETWINDOWTHEME
    } Tooltip_Messages;
	typedef struct _TTGETTITLE
	{
		LONG dwSize;
		LONG uTitleBitmap;
		LONG cch;
		LONG pszTitle;
	} TTGETTITLE;
	
    typedef enum Tooltip_Icon {
        TTI_NONE = 0,
        TTI_INFO = 1,
        TTI_WARNING = 2,
        TTI_ERROR = 3,
		TTI_INFO_LARGE = 4,
		TTI_WARNING_LARGE = 5,
		TTI_ERROR_LARGE = 6,
    } Tooltip_Icon;

    typedef struct TTHITTESTINFO {
        LONG hwnd;
        POINT pt;
        TTTOOLINFO ti;
    } TTHITTESTINFO;

    typedef enum Tooltip_NotifycationCodes {
        TTN_GETDISPINFO = (-520 - 0),
        TTN_GETDISPINFOW = (-520 - 10),
        TTN_SHOW = (-520 - 1),
        TTN_POP = (-520 - 2),
        TTN_NEEDTEXT = TTN_GETDISPINFO,
        TTN_NEEDTEXTW = TTN_GETDISPINFOW,
    } Tooltip_NotifycationCodes;

    typedef struct NMTTDISPIFNO {
        NMHDR hdr;
        LONG lpszText;
        BYTE szText[80];
        LONG hinst;
        LONG uFlags;
        LONG lParam;
    } NMTTDISPINFO;

    typedef struct NMTTDISPINFOW {
        NMHDR hdr;
        LONG lpszText;
        BYTE szText[160];
        LONG hinst;
        LONG uFlags;
        LONG lParam;
    } NMTTDISPINFOW;

 // = === STATUS BAR CONTROL = =====================================

    [
        helpstring("StatusBar control"),
        dllname("comctl32.dll")
    ]
    module StatusBar {

        const LONG SBARS_SIZEGRIP = 0x0100;
        const LONG SBARS_TOOLTIPS = 0x0800;
        const LONG SB_SIMPLEID = 0x00ff;

        [entry("DrawStatusTextA")]
        void DrawStatusText(
            [in] LONG hDC,
            [in] RECT *lprc,
            [in] LPSTR pszText,
            [in] LONG uFlags);

        [entry("DrawStatusTextW")]
        void DrawStatusTextW(
            [in] LONG hDC,
            [in] RECT *lprc,
            [in] LPOLESTR pszText,
            [in] LONG uFlags);

        [entry("CreateStatusWindowA ")]
        LONG CreateStatusWindow(
            [in] LONG style,
            [in] LPSTR lpszText,
            [in] LONG hwndParent,
            [in] LONG wID);

        [entry("CreateStatusWindowW")]
        LONG CreateStatusWindowW(
            [in] LONG style,
            [in] LPOLESTR lpszText,
            [in] LONG hwndParent,
            [in] LONG wID);

        const LPSTR STATUSCLASSNAMEW = "msctls_statusbar32";

    }

    typedef enum StatusBar_Messages {
        SB_SETTEXT = (0x400+1),
        SB_SETTEXTW = (0x400+11),
        SB_GETTEXT = (0x400+2),
        SB_GETTEXTW = (0x400+13),
        SB_GETTEXTLENGTH = (0x400+3),
        SB_GETTEXTLENGTHW = (0x400+12),
        SB_SETPARTS = (0x400+4),
        SB_GETPARTS = (0x400+6),
        SB_GETBORDERS = (0x400+7),
        SB_SETMINHEIGHT = (0x400+8),
        SB_SIMPLE = (0x400+9),
        SB_GETRECT = (0x400+10),
        SB_ISSIMPLE = (0x400+14),
        SB_SETICON = (0x400+15),
        SB_SETTIPTEXT = (0x400+16),
        SB_SETTIPTEXTW = (0x400+17),
        SB_GETTIPTEXT = (0x400+18),
        SB_GETTIPTEXTW = (0x400+19),
		SB_GETICON = (0x400+20),
        SB_SETBKCOLOR = CCM_SETBKCOLOR,
		SB_SETUNICODEFORMAT = CCM_SETUNICODEFORMAT,
		SB_GETUNICODEFORMAT = CCM_GETUNICODEFORMAT,
    } StatusBar_Messages;

    typedef enum StatusBar_Ts {
        SBT_OWNERDRAW = 0x1000,
        SBT_NOBORDERS = 0x0100,
        SBT_POPOUT = 0x0200,
        SBT_RTLREADING = 0x0400,
        SBT_TOOLTIPS = 0x0800,
        SBT_NOTABPARSING = 0x0800,
    } StatusBar_Ts;


    typedef enum StatusBar_NotificationCodes {
        SBN_SIMPLEMODECHANGE = (-880 - 0),
    } StatusBar_NotificationCodes;


    [
        dllname("comctl32.dll")
    ]
    module MenuHelp {

        [entry("MenuHelp")]
        void MenuHelp(
            LONG uMsg,
            LONG wParam,
            LONG lParam,
            LONG hMainMenu,
            LONG hInst,
            LONG hwndStatus,
            LONG *lpwIDs);

        [entry("ShowHideMenuCtl")]
        BOOL ShowHideMenuCtl(
            LONG hWnd,
            LONG uFlags,
            LONG *lpInfo);

        [entry("GetEffectiveClientRect")]
        void GetEffectiveClientRect(
            LONG hWnd,
            RECT *lprc,
            LONG *lpInfo);

//        const LONG MINSYSCOMMAND = SC_SIZE;
    };


// = ==== TRACKBAR CONTROL = ======

    [
        dllname("comctl32.dll")
    ]
    module TrackBar {

        const LPSTR TRACKBAR_CLASS = "msctls_trackbar32";
		const LONG TRBN_THUMBPOSCHANGING = (-1501-1);

    };

    typedef enum TrackBarStyles {
        TBS_AUTOTICKS = 0x0001,
        TBS_VERT = 0x0002,
        TBS_HORZ = 0x0000,
        TBS_TOP = 0x0004,
        TBS_BOTTOM = 0x0000,
        TBS_LEFT = 0x0004,
        TBS_RIGHT = 0x0000,
        TBS_BOTH = 0x0008,
        TBS_NOTICKS = 0x0010,
        TBS_ENABLESELRANGE = 0x0020,
        TBS_FIXEDLENGTH = 0x0040,
        TBS_NOTHUMB = 0x0080,
        TBS_TOOLTIPS = 0x0100,
        TBS_REVERSED = 0x0200,
		TBS_DOWNISLEFT = 0x0400,
		TBS_NOTIFYBEFOREREMOVE = 0x0800,
		TBS_TRANSPARENTBKGND = 0x1000,
    } TrackBarStyles;

    typedef enum TrackbarMessages {
        TBM_GETPOS = (0x400),
        TBM_GETRANGEMIN = (0x400+1),
        TBM_GETRANGEMAX = (0x400+2),
        TBM_GETTIC = (0x400+3),
        TBM_SETTIC = (0x400+4),
        TBM_SETPOS = (0x400+5),
        TBM_SETRANGE = (0x400+6),
        TBM_SETRANGEMIN = (0x400+7),
        TBM_SETRANGEMAX = (0x400+8),
        TBM_CLEARTICS = (0x400+9),
        TBM_SETSEL = (0x400+10),
        TBM_SETSELSTART = (0x400+11),
        TBM_SETSELEND = (0x400+12),
        TBM_GETPTICS = (0x400+14),
        TBM_GETTICPOS = (0x400+15),
        TBM_GETNUMTICS = (0x400+16),
        TBM_GETSELSTART = (0x400+17),
        TBM_GETSELEND = (0x400+18),
        TBM_CLEARSEL = (0x400+19),
        TBM_SETTICFREQ = (0x400+20),
        TBM_SETPAGESIZE = (0x400+21),
        TBM_GETPAGESIZE = (0x400+22),
        TBM_SETLINESIZE = (0x400+23),
        TBM_GETLINESIZE = (0x400+24),
        TBM_GETTHUMBRECT = (0x400+25),
        TBM_GETCHANNELRECT = (0x400+26),
        TBM_SETTHUMBLENGTH = (0x400+27),
        TBM_GETTHUMBLENGTH = (0x400+28),
        TBM_SETTOOLTIPS = (0x400+29),
        TBM_GETTOOLTIPS = (0x400+30),
        TBM_SETTIPSIDE = (0x400+31),
        TBM_SETBUDDY = (0x400+32), // wparam = BOOL fLeft; (or right)
        TBM_GETBUDDY = (0x400+33), // wparam = BOOL fLeft; (or right)
		TBM_SETPOSNOTIFY = (0x400+34),
		TBM_SETUNICODEFORMAT  =  CCM_SETUNICODEFORMAT,
		TBM_GETUNICODEFORMAT  =  CCM_GETUNICODEFORMAT,

    } TrackbarMessages;

    typedef enum TrackBarTipSideFlags {
        TBTS_TOP = 0,
        TBTS_LEFT = 1,
        TBTS_BOTTOM = 2,
        TBTS_RIGHT = 3,
    } TrackBarTipSideFlags;

    typedef enum TrackBarNotifications {
        TB_LINEUP = 0,
        TB_LINEDOWN = 1,
        TB_PAGEUP = 2,
        TB_PAGEDOWN = 3,
        TB_THUMBPOSITION = 4,
        TB_THUMBTRACK = 5,
        TB_TOP = 6,
        TB_BOTTOM = 7,
        TB_ENDTRACK = 8,
    } TrackBarNotifications;

    typedef enum TrackBarItemSpecs {
        TBCD_TICS = 0x0001,
        TBCD_THUMB = 0x0002,
        TBCD_CHANNEL = 0x0003,
    } TrackBarItemSpecs;

	typedef struct NMTRBTHUMBPOSCHANGING
	{
		NMHDR hdr;
		LONG dwPos;
		int nReason;
	} NMTRBTHUMBPOSCHANGING;
// = ===== DRAG LIST CONTROL = ==============================


    typedef struct DRAGLISTINFO {
        LONG uNotification;
        LONG hWnd;
        POINT ptCursor;
    } DRAGLISTINFO;

    typedef enum DragListMessages {
        DL_BEGINDRAG = (0x400+133),
        DL_DRAGGING = (0x400+134),
        DL_DROPPED = (0x400+135),
        DL_CANCELDRAG = (0x400+136),
    } DragListMessages;

    typedef enum DragListCursor {
        DL_CURSORSET = 0,
        DL_STOPCURSOR = 1,
        DL_COPYCURSOR = 2,
        DL_MOVECURSOR = 3,
    } DragListCursor;

    [
        dllname("comctl32.dll")
    ]
    module DragListBox {

        const LPSTR DRAGLISTMSGSTRING = "commctrl_DragListMsg";

        [entry("MakeDragList")]
        BOOL MakeDragList(LONG hLB);

        [entry("DrawInsert")]
        void DrawInsert(LONG handParent, LONG hLB, LONG nItem);

        [entry("LBItemFromPt")]
        LONG LBItemFromPt(LONG hLB, POINT pt, BOOL bAutoScroll);

    };


// = = ====UPDOWN CONTROL = = =====================================================

    [
        dllname("comctl32.dll")
    ]
    module UpDown {

        const LPSTR UPDOWN_CLASS = "msctls_updown32";

        const short UD_MAXVAL = 0x7fff;
        const short UD_MINVAL = 0x8000;

        [entry("CreateUpDownControl")]
        LONG CreateUpDownControl(
            LONG dwStyle,
            LONG x,
            LONG y,
            LONG cx,
            LONG cy,
            LONG hParent,
            LONG nID,
            LONG hInst,
            LONG hBuddy,
            LONG nUpper,
            LONG nLower,
            LONG nPos);

    };

    typedef struct UDACCEL {
        LONG nSec;
        LONG nInc;
    } UDACCEL;

    typedef enum UpDownStyles {
        UDS_WRAP = 0x0001,
        UDS_SETBUDDYINT = 0x0002,
        UDS_ALIGNRIGHT = 0x0004,
        UDS_ALIGNLEFT = 0x0008,
        UDS_AUTOBUDDY = 0x0010,
        UDS_ARROWKEYS = 0x0020,
        UDS_HORZ = 0x0040,
        UDS_NOTHOUSANDS = 0x0080,
        UDS_HOTTRACK = 0x0100,
    } UpDownStyles;

    typedef enum UpDownMessages {
        UDM_SETRANGE = (0x400+101),
        UDM_GETRANGE = (0x400+102),
        UDM_SETPOS = (0x400+103),
        UDM_GETPOS = (0x400+104),
        UDM_SETBUDDY = (0x400+105),
        UDM_GETBUDDY = (0x400+106),
        UDM_SETACCEL = (0x400+107),
        UDM_GETACCEL = (0x400+108),
        UDM_SETBASE = (0x400+109),
        UDM_GETBASE = (0x400+110),
        UDM_SETRANGE32 = (0x400+111),
        UDM_GETRANGE32 = (0x400+112), // wParam & lParam are LPINT
        UDM_SETPOS32 = (0x400+113),
        UDM_GETPOS32 = (0x400+114),
		UDM_SETUNICODEFORMAT  = CCM_SETUNICODEFORMAT,
		UDM_GETUNICODEFORMAT  = CCM_GETUNICODEFORMAT,
    } UpDownMessages;

    typedef struct NMUPDOWN {
        NMHDR hdr;
        LONG iPos;
        LONG iDelta;
    } NMUPDOWN;

    typedef enum UpDownNotifications {
        UDN_DELTAPOS = (-721 - 1)
    } UpDownNotifications;

// = == PROGRESS CONTROL = ===========================


    [
        dllname("comctl32.dll"),
        helpstring("Progress Bar")
    ]
    module Progress {

        const LPSTR PROGRESS_CLASS = "msctls_progress32";

    }

    typedef enum ProgressStyles {
        PBS_SMOOTH = 0x01,
        PBS_VERTICAL = 0x04,
		PBS_MARQUEE = 0x08,
		PBS_SMOOTHREVERSE = 0x10,
    } ProgressStyles;

    typedef enum ProgressMessages {
        PBM_SETRANGE = (0x400+1),
        PBM_SETPOS = (0x400+2),
        PBM_DELTAPOS = (0x400+3),
        PBM_SETSTEP = (0x400+4),
        PBM_STEPIT = (0x400+5),
        PBM_SETRANGE32 = (0x400+6), // lParam = high, wParam = low
        PBM_GETRANGE = (0x400+7), // wParam = return (TRUE ? low : high).
        PBM_GETPOS = (0x400+8),
		PBM_SETBARCOLOR = (0x400+9),
		PBM_SETMARQUEE = (0x400+10),
		PBM_SETBKCOLOR = CCM_SETBKCOLOR,
		PBM_GETSTEP = (0x400+13),
		PBM_GETBKCOLOR = (0x400+14),
		PBM_GETBARCOLOR = (0x400+15),
		PBM_SETSTATE = (0x400+16), // wParam = PBST_[State] (NORMAL, ERROR, PAUSED)
		PBM_GETSTATE = (0x400+17),

    } ProgressMessages;

    typedef struct PBRANGE {
        LONG iLow;
        LONG iHigh;
    } PBRANGE;

	typedef enum ProgressState
	{
		PBST_NORMAL = 0x001,
		PBST_ERROR = 0x002,
		PBST_PAUSED = 0x003,
	} ProgressState;



// = ========= HOTKEY CONTROL = =========


    typedef enum HotKeyFlags {
        HOTKEYF_SHIFT = 0x01,
        HOTKEYF_CONTROL = 0x02,
        HOTKEYF_ALT = 0x04,
        HOTKEYF_EXT = 0x08,
    } HotKeyFlags;

    typedef enum HotKeyRulesCombinations {
        HKCOMB_NONE = 0x0001,
        HKCOMB_S = 0x0002,
        HKCOMB_C = 0x0004,
        HKCOMB_A = 0x0008,
        HKCOMB_SC = 0x0010,
        HKCOMB_SA = 0x0020,
        HKCOMB_CA = 0x0040,
        HKCOMB_SCA = 0x0080,
    } HotKeyRulesCombinations;

    typedef enum HotKeyMessages {
        HKM_SETHOTKEY = (0x400+1),
        HKM_GETHOTKEY = (0x400+2),
        HKM_SETRULES = (0x400+3),
    } HotKeyMessages;

    [
        dllname("comctl32.dll"),
        helpstring("HotKey")
    ]
    module HotKey {

        const LPSTR HOTKEY_CLASS = "msctls_hotkey32";
    }


//===== SysLink Control =========
    [
        dllname("comctl32.dll"),
        helpstring("SysLink")
    ]
    module SysLink {

        const LPSTR WC_LINK = "SysLink";
		const LONG INVALID_LINK_INDEX = (-1);
		const LONG MAX_LINKID_TEXT = 48;

    }

	typedef enum SysLinkStyles 
	{
        LWS_TRANSPARENT    = 0x0001,
        LWS_IGNORERETURN   = 0x0002,
        LWS_NOPREFIX       = 0x0004,
        LWS_USEVISUALSTYLE = 0x0008,
        LWS_USECUSTOMTEXT  = 0x0010,
        LWS_RIGHT          = 0x0020,
	} SysLinkStyles;
	
	typedef enum SysLinkItemMask
	{
        LIF_ITEMINDEX   = 0x00000001,
        LIF_STATE       = 0x00000002,
        LIF_ITEMID      = 0x00000004,
        LIF_URL         = 0x00000008,
	} SysLinkItemMask;

	typedef enum SysLinkStates
	{
        LIS_FOCUSED        = 0x00000001,
        LIS_ENABLED        = 0x00000002,
        LIS_VISITED        = 0x00000004,
        LIS_HOTTRACK       = 0x00000008,
        LIS_DEFAULTCOLORS  = 0x00000010, // Don't use any custom text colors
	} SysLinkStates;

	typedef struct LITEM
	{
		LONG        mask;
		int         iLink;
		LONG        state;
		LONG        stateMask;
		WCHAR       szID[48];
		WCHAR       szUrl[2084];
	} LITEM;

	typedef struct LHITTESTINFO
	{
		POINT       pt;
		LITEM     item;
	} LHITTESTINFO;

	typedef struct NMLINK
	{
		NMHDR       hdr;
		LITEM     item ;
	} NMLINK;

	typedef enum LinkWindow_Messages
	{
		LM_HITTEST        = (0x400+0x300),  // wParam: n/a, lparam: PLHITTESTINFO, ret: BOOL
		LM_GETIDEALHEIGHT = (0x400+0x301),  // wParam: cxMaxWidth, lparam: n/a, ret: cy
		LM_SETITEM        = (0x400+0x302),  // wParam: n/a, lparam: LITEM*, ret: BOOL
		LM_GETITEM        = (0x400+0x303),  // wParam: n/a, lparam: LITEM*, ret: BOOL
		LM_GETIDEALSIZE   = (0x400+0x301), // (LM_GETIDEALHEIGHT)  // wParam: cxMaxWidth, lparam: SIZE*, ret: cy
	} LinkWindow_Messages;


// = = ====LISTVIEW CONTROL = = =====

	[
        dllname("comctl32.dll"),
        helpstring("ListView Control")
    ]
    module ListView {

        const LPSTR WC_LISTVIEW = "SysListView32";
        const short LV_MAX_WORKAREAS = 16;
		const LONG LVIM_AFTER = 0x01;
    }

typedef struct LVITEMINDEX
{
    int iItem;          // listview item index
    int iGroup;         // group index (must be -1 if group view is not enabled)
} LVITEMINDEX;
typedef struct LVFooterButton {
	BSTR pszText;
	LONG nIcon;
	LONG lId;
} LVFooterButton;
typedef struct LVFOOTERINFO {
	LONG mask;
	LONG pszTest;
	LONG cchText; //
	LONG cItems;
} LVFOOTERINFO;
typedef enum LVFOOTERITEM_Flags
{
	LVFIF_TEXT = 0x01,
	LVFIF_STATE = 0x02,
} LVFOOTERITEM_Flags;
typedef struct LVFOOTERITEM {
	LVFOOTERITEM_Flags mask;
	LONG iItem;
	LONG pszText;
	LONG cchTextMax;
	LONG state;
	LONG stateMask;
} LVFOOTERITEM;
typedef struct LVINSERTMARK {
	LONG cbSize;
	LONG dwFlags;
	LONG iItem;
	LONG dwReserved;
} LVINSERTMARK;
typedef struct LVSETINFOTIP {
	LONG cbSize;
	LONG dwFlags;
	LONG pszText;
	LONG iItem;
	LONG iSubItem;
} LVSETINFOTIP;
typedef struct LVTILEINFO {
	LONG cbSize;
	LONG iItem;
	LONG cColumns;
	LONG puColumns;
	LONG piColFmt;
} LVTILEINFO;
typedef enum LV_VIEW
{
    LV_VIEW_ICON = 0x0,
    LV_VIEW_DETAILS = 0x1,
    LV_VIEW_SMALLICON = 0x2,
    LV_VIEW_LIST = 0x3,
    LV_VIEW_TILE = 0x4,
//below are not part of API, but are valid views nonetheless
    LV_VIEW_XLICON = 0x5,
    LV_VIEW_THUMBNAIL = 0x6,
} LV_VIEW;

typedef enum LVTVI_Flags
{
    LVTVIF_AUTOSIZE = 0x0,
    LVTVIF_FIXEDWIDTH = 0x1,
    LVTVIF_FIXEDHEIGHT = 0x2,
    LVTVIF_FIXEDSIZE = 0x3,
    LVTVIF_EXTENDED = 0x4,
} LVTVI_Flags;

typedef enum  LVTVI_Mask
{
    LVTVIM_TILESIZE = 0x1,
    LVTVIM_COLUMNS = 0x2,
    LVTVIM_LABELMARGIN = 0x4,
} LVTVI_Mask;

typedef struct LVTILEVIEWINFO {
    LONG cbSize;
    LVTVI_Mask dwMask;  //LVTVIM_*
    LVTVI_Flags dwFlags; //LVTVIF_*
    SIZE SizeTile;
    LONG cLines;
    RECT RCLabelMargin;
} LVTILEVIEWINFO;







    typedef enum ListViewStyles {
        LVS_ICON = 0x0000,
        LVS_REPORT = 0x0001,
        LVS_SMALLICON = 0x0002,
        LVS_LIST = 0x0003,
        LVS_TYPEMASK = 0x0003,
        LVS_SINGLESEL = 0x0004,
        LVS_SHOWSELALWAYS = 0x0008,
        LVS_SORTASCENDING = 0x0010,
        LVS_SORTDESCENDING = 0x0020,
        LVS_SHAREIMAGELISTS = 0x0040,
        LVS_NOLABELWRAP = 0x0080,
        LVS_AUTOARRANGE = 0x0100,
        LVS_EDITLABELS = 0x0200,
        LVS_OWNERDATA = 0x1000,
        LVS_NOSCROLL = 0x2000,
        LVS_TYPESTYLEMASK = 0xfc00,
        LVS_ALIGNTOP = 0x0000,
        LVS_ALIGNLEFT = 0x0800,
        LVS_ALIGNMASK = 0x0c00,
        LVS_OWNERDRAWFIXED = 0x0400,
        LVS_NOCOLUMNHEADER = 0x4000,
        LVS_NOSORTHEADER = 0x8000,
    } ListViewStyles;

typedef enum ListViewImageListStyle {
    LVSIL_NORMAL = 0,
    LVSIL_SMALL = 1,
    LVSIL_STATE = 2,
	LVSIL_GROUPHEADER = 3,
	LVSIL_FOOTER = 4, //UNDOCUMENTED, for IListViewFooter
} ListViewImageListStyle;

typedef enum ListViewItemFlags {
    LVIF_TEXT = 0x0001,
    LVIF_IMAGE = 0x0002,
    LVIF_PARAM = 0x0004,
    LVIF_STATE = 0x0008,
    LVIF_INDENT = 0x0010,
    LVIF_NORECOMPUTE = 0x0800,
    LVIF_DI_SETITEM = 0x1000,
	LVIF_COLFMT = 0x10000,
} ListViewItemFlags;

typedef enum ListViewItemStates {
    LVIS_FOCUSED = 0x0001,
    LVIS_SELECTED = 0x0002,
    LVIS_CUT = 0x0004,
    LVIS_DROPHILITED = 0x0008,
    LVIS_OVERLAYMASK = 0x0F00,
    LVIS_STATEIMAGEMASK = 0xF000,
} ListViewItemStates;

typedef struct LVITEM {
    ListViewItemFlags mask;
    LONG iItem;
    LONG iSubItem;
    ListViewItemStates state;
    ListViewItemStates stateMask;
    LONG pszText;
    LONG cchTextMax;
    LONG iImage;
    LONG lParam;
    LONG iIndent;
	LONG iGroupId;
	LONG cColumns;
	LONG puColumns;
	LONG piColFmt;
	LONG iGroup;
} LVITEM;

typedef enum ListViewImages {
    I_IMAGECALLBACK = (-1),
    I_IMAGENONE = (-2),
	I_COLUMNSCALLBACK = (-1),
	I_GROUPIDCALLBACK = (-1),
	I_GROUPIDNONE = (-2),
	LPSTR_TEXTCALLBACKA = (-1),
	LPSTR_TEXTCALLBACKW = (-1),
} ListViewCallbacks;

typedef enum ListViewNextItemFlags {
    LVNI_ALL = 0x0000,
    LVNI_FOCUSED = 0x0001,
    LVNI_SELECTED = 0x0002,
    LVNI_CUT = 0x0004,
    LVNI_DROPHILITED = 0x0008,
    LVNI_ABOVE = 0x0100,
    LVNI_BELOW = 0x0200,
    LVNI_TOLEFT = 0x0400,
    LVNI_TORIGHT = 0x0800,
    LVNI_STATEMASK = 15, //(LVNI_FOCUSED Or LVNI_SELECTED Or LVNI_CUT Or LVNI_DROPHILITED)
    LVNI_DIRECTIONMASK = 3840, //(LVNI_ABOVE Or LVNI_BELOW Or LVNI_TOLEFT Or LVNI_TORIGHT)
    LVNI_PREVIOUS = 0x20,
    LVNI_VISIBLEORDER = 0x10,
    LVNI_VISIBLEONLY = 0x40,
    LVNI_SAMEGROUPONLY = 0x80,
} ListViewNextItemFlags;

typedef enum ListViewFindIndoFlags {
    LVFI_PARAM = 0x0001,
    LVFI_STRING = 0x0002,
    LVFI_PARTIAL = 0x0008,
    LVFI_WRAP = 0x0020,
    LVFI_NEARESTXY = 0x0040,
} ListViewFindIndoFlags;

typedef struct LVFINDINFO
{
    ListViewFindIndoFlags flags;
    LONG psz;
    LONG lParam;
    POINT pt;
    LONG vkDirection;
} LVFINDINFO;

typedef enum ListViewItemRectFlags {
    LVIR_BOUNDS = 0,
    LVIR_ICON = 1,
    LVIR_LABEL = 2,
    LVIR_SELECTBOUNDS = 3,
} ListViewItemRectFlags;

typedef enum ListViewHitTest {
    LVHT_NOWHERE = 0x0001,
    LVHT_ONITEMICON = 0x0002,
    LVHT_ONITEMLABEL = 0x0004,
    LVHT_ONITEMSTATEICON = 0x0008,
    LVHT_ONITEM = 0x000F,
	LVHT_ABOVE = 0x0008,
	LVHT_BELOW = 0x0010,
	LVHT_TORIGHT = 0x0020,
	LVHT_TOLEFT = 0x0040,
    LVHT_EX_GROUP_HEADER = 0x10000000,
    LVHT_EX_GROUP_FOOTER = 0x20000000,
    LVHT_EX_GROUP_COLLAPSE = 0x40000000,
    LVHT_EX_GROUP_BACKGROUND = 0x80000000,
    LVHT_EX_GROUP_STATEICON = 0x1000000,
    LVHT_EX_GROUP_SUBSETLINK = 0x2000000,
    LVHT_EX_GROUP = 0xF3000000, //(LVHT_EX_GROUP_BACKGROUND Or LVHT_EX_GROUP_COLLAPSE Or LVHT_EX_GROUP_FOOTER Or LVHT_EX_GROUP_HEADER Or LVHT_EX_GROUP_STATEICON Or LVHT_EX_GROUP_SUBSETLINK)
    LVHT_EX_ONCONTENTS = 0x4000000, //On item AND not on the background
    LVHT_EX_FOOTER = 0x8000000,

} ListViewHitTest;

typedef struct LVHITTESTINFO
{
    POINT pt;
    ListViewHitTest flags;
    LONG iItem;
    LONG iSubItem; // valid only for LVM_SUBITEMHITTEST
} LVHITTESTINFO;

typedef enum ListViewArrangeFlags {
    LVA_DEFAULT = 0x0000,
    LVA_ALIGNLEFT = 0x0001,
    LVA_ALIGNTOP = 0x0002,
    LVA_SNAPTOGRID = 0x0005,
} ListViewArrangeFlags;

typedef enum ListViewColumnMasks {
    LVCF_FMT = 0x0001,
    LVCF_WIDTH = 0x0002,
    LVCF_TEXT = 0x0004,
    LVCF_SUBITEM = 0x0008,
    LVCF_IMAGE = 0x0010,
    LVCF_ORDER = 0x0020,
	LVCF_MINWIDTH = 0x40,
	LVCF_DEFAULTWIDTH = 0x80,
	LVCF_IDEALWIDTH = 0x100,
} ListViewColumnMasks;

typedef enum ListViewColumnFormats {
    LVCFMT_LEFT = 0x0000,
    LVCFMT_RIGHT = 0x0001,
    LVCFMT_CENTER = 0x0002,
    LVCFMT_JUSTIFYMASK = 0x0003,
    LVCFMT_IMAGE = 0x0800,
    LVCFMT_BITMAP_ON_RIGHT = 0x1000,
    LVCFMT_COL_HAS_IMAGES = 0x8000,
  LVCFMT_FIXED_WIDTH = 0x100,
  LVCFMT_NO_DPI_SCALE = 0x40000,
  LVCFMT_FIXED_RATIO = 0x80000,
  LVCFMT_LINE_BREAK = 0x100000,
  LVCFMT_FILL = 0x200000,
  LVCFMT_WRAP = 0x400000,
  LVCFMT_NO_TITLE = 0x800000,
  LVCFMT_TILE_PLACEMENTMASK = 3145728, //(LVCFMT_LINE_BREAK Or LVCFMT_FILL)
  LVCFMT_SPLITBUTTON = 0x1000000

} ListViewColumnFormats;

typedef struct LVCOLUMN
{
    ListViewColumnMasks mask;
    ListViewColumnFormats fmt;
    LONG cx;
    LONG pszText;
    LONG cchTextMax;
    LONG iSubItem;
    LONG iImage;
    LONG iOrder;
	LONG cxMin;
	LONG cxDefault;
	LONG cxIdeal;
} LVCOLUMN;

typedef enum ListViewColumnWidth {
    LVSCW_AUTOSIZE = -1,
    LVSCW_AUTOSIZE_USEHEADER = -2,
} ListViewColumnWidth;

typedef enum ListViewItemCountFlags {
    LVSICF_NOINVALIDATEALL = 0x00000001,
    LVSICF_NOSCROLL = 0x00000002,
} ListViewItemCountFlags;

typedef enum ListViewExtendedStyles {
    LVS_EX_GRIDLINES = 0x00000001,
    LVS_EX_SUBITEMIMAGES = 0x00000002,
    LVS_EX_CHECKBOXES = 0x00000004,
    LVS_EX_TRACKSELECT = 0x00000008,
    LVS_EX_HEADERDRAGDROP = 0x00000010,
    LVS_EX_FULLROWSELECT = 0x00000020, // applies to report mode only
    LVS_EX_ONECLICKACTIVATE = 0x00000040,
    LVS_EX_TWOCLICKACTIVATE = 0x00000080,
    LVS_EX_FLATSB = 0x00000100, // cannot be cleared
    LVS_EX_REGIONAL = 0x00000200,
    LVS_EX_INFOTIP = 0x00000400, // listview does InfoTips for you
    LVS_EX_UNDERLINEHOT = 0x00000800,
    LVS_EX_UNDERLINECOLD = 0x00001000,
    LVS_EX_MULTIWORKAREAS = 0x00002000,
    LVS_EX_LABELTIP = 0x00004000,
  LVS_EX_BORDERSELECT = 0x8000,
  LVS_EX_DOUBLEBUFFER = 0x10000,
  LVS_EX_HIDELABELS = 0x20000,
  LVS_EX_SINGLEROW = 0x40000,
  LVS_EX_SNAPTOGRID = 0x80000, // Icons automatically snap to grid.
  LVS_EX_SIMPLESELECT = 0x100000,        // Also changes overlay rendering to top right for icon mode.
  LVS_EX_JUSTIFYCOLUMNS = 0x200000,      // Icons are lined up in columns that use up the whole view area.
  LVS_EX_TRANSPARENTBKGND = 0x400000,    // Background is painted by the parent via WM_PRINTCLIENT
  LVS_EX_TRANSPARENTSHADOWTEXT = 0x800000,    // Enable shadow text on transparent backgrounds only (useful with bitmaps)
  LVS_EX_AUTOAUTOARRANGE = 0x1000000,    // Icons automatically arrange if no icon positions have been set
  LVS_EX_HEADERINALLVIEWS = 0x2000000,   // Display column header in all view modes
  LVS_EX_DRAWIMAGEASYNC = 0x4000000,     //UNDOCUMENTED. LVN_ASYNCDRAW, NMLVASYNCDRAW
  LVS_EX_AUTOCHECKSELECT = 0x8000000,
  LVS_EX_AUTOSIZECOLUMNS = 0x10000000,
  LVS_EX_COLUMNSNAPPOINTS = 0x40000000,
  LVS_EX_COLUMNOVERFLOW = 0x80000000,

} ListViewExtendedStyles;

typedef enum ListViewBkImageFlags {
    LVBKIF_SOURCE_NONE = 0x00000000,
    LVBKIF_SOURCE_LONG = 0x00000001,
    LVBKIF_SOURCE_URL = 0x00000002,
    LVBKIF_SOURCE_MASK = 0x00000003,
    LVBKIF_STYLE_NORMAL = 0x00000000,
    LVBKIF_STYLE_TILE = 0x00000010,
    LVBKIF_STYLE_MASK = 0x00000010,
    LVBKIF_FLAG_TILEOFFSET = 0x100,
    LVBKIF_TYPE_WATERMARK = 0x10000000,
    LVBKIF_FLAG_ALPHABLEND = 0x20000000,
} ListViewBkImageFlags;

typedef struct LVBKIMAGE {
    ListViewBkImageFlags ulFlags; // LVBKIF_*
    LONG hbm;
    LONG pszImage;
    LONG cchImageMax;
    LONG xOffsetPercent;
    LONG yOffsetPercent;
} LVBKIMAGE;

typedef enum ListViewMessages {
	LVM_FIRST = 0x1000,
    LVM_GETBKCOLOR = (LVM_FIRST + 0),
    LVM_SETBKCOLOR = (LVM_FIRST + 1),
    LVM_GETIMAGELIST = (LVM_FIRST + 2),
    LVM_SETIMAGELIST = (LVM_FIRST + 3),
    LVM_GETITEMCOUNT = (LVM_FIRST + 4),
    LVM_GETITEM = (LVM_FIRST + 5),
    LVM_SETITEM = (LVM_FIRST + 6),
    LVM_INSERTITEM = (LVM_FIRST + 7),
    LVM_DELETEITEM = (LVM_FIRST + 8),
    LVM_DELETEALLITEMS = (LVM_FIRST + 9),
    LVM_GETCALLBACKMASK = (LVM_FIRST + 10),
    LVM_SETCALLBACKMASK = (LVM_FIRST + 11),
    LVM_GETNEXTITEM = (LVM_FIRST + 12),
    LVM_FINDITEM = (LVM_FIRST + 13),
    LVM_GETITEMRECT = (LVM_FIRST + 14),
    LVM_SETITEMPOSITION = (LVM_FIRST + 15),
    LVM_GETITEMPOSITION = (LVM_FIRST + 16),
    LVM_GETSTRINGWIDTH = (LVM_FIRST + 17),
    LVM_HITTEST = (LVM_FIRST + 18),
    LVM_ENSUREVISIBLE = (LVM_FIRST + 19),
    LVM_SCROLL = (LVM_FIRST + 20),
    LVM_REDRAWITEMS = (LVM_FIRST + 21),
    LVM_ARRANGE = (LVM_FIRST + 22),
    LVM_EDITLABEL = (LVM_FIRST + 23),
    LVM_GETEDITCONTROL = (LVM_FIRST + 24),
    LVM_GETCOLUMN = (LVM_FIRST + 25),
    LVM_SETCOLUMN = (LVM_FIRST + 26),
    LVM_INSERTCOLUMN = (LVM_FIRST + 27),
    LVM_DELETECOLUMN = (LVM_FIRST + 28),
    LVM_GETCOLUMNWIDTH = (LVM_FIRST + 29),
    LVM_SETCOLUMNWIDTH = (LVM_FIRST + 30),
    LVM_GETHEADER = (LVM_FIRST + 31),
    LVM_CREATEDRAGIMAGE = (LVM_FIRST + 33),
    LVM_GETVIEWRECT = (LVM_FIRST + 34),
    LVM_GETTEXTCOLOR = (LVM_FIRST + 35),
    LVM_SETTEXTCOLOR = (LVM_FIRST + 36),
    LVM_GETTEXTBKCOLOR = (LVM_FIRST + 37),
    LVM_SETTEXTBKCOLOR = (LVM_FIRST + 38),
    LVM_GETTOPINDEX = (LVM_FIRST + 39),
    LVM_GETCOUNTPERPAGE = (LVM_FIRST + 40),
    LVM_GETORIGIN = (LVM_FIRST + 41),
    LVM_UPDATE = (LVM_FIRST + 42),
    LVM_SETITEMSTATE = (LVM_FIRST + 43),
    LVM_GETITEMSTATE  = (LVM_FIRST + 44),
    LVM_GETITEMTEXT = (LVM_FIRST + 45),
    LVM_SETITEMTEXT = (LVM_FIRST + 46),
    LVM_SETITEMCOUNT = (LVM_FIRST + 47),
    LVM_SORTITEMS = (LVM_FIRST + 48),
    LVM_SETITEMPOSITION32 = (LVM_FIRST + 49),
    LVM_GETSELECTEDCOUNT = (LVM_FIRST + 50),
    LVM_GETITEMSPACING = (LVM_FIRST + 51),
    LVM_GETISEARCHSTRING = (LVM_FIRST + 52),
    LVM_SETICONSPACING = (LVM_FIRST + 53),
    LVM_SETEXTENDEDLISTVIEWSTYLE = (LVM_FIRST + 54),
    LVM_GETEXTENDEDLISTVIEWSTYLE = (LVM_FIRST + 55),
    LVM_GETSUBITEMRECT = (LVM_FIRST + 56),
    LVM_SUBITEMHITTEST = (LVM_FIRST + 57),
    LVM_SETCOLUMNORDERARRAY = (LVM_FIRST + 58),
    LVM_GETCOLUMNORDERARRAY = (LVM_FIRST + 59),
    LVM_SETHOTITEM = (LVM_FIRST + 60),
    LVM_GETHOTITEM = (LVM_FIRST + 61),
    LVM_SETHOTCURSOR = (LVM_FIRST + 62),
    LVM_GETHOTCURSOR = (LVM_FIRST + 63),
    LVM_APPROXIMATEVIEWRECT = (LVM_FIRST + 64),
    LVM_SETWORKAREAS = (LVM_FIRST + 65),
    LVM_GETSELECTIONMARK = (LVM_FIRST + 66),
    LVM_SETSELECTIONMARK = (LVM_FIRST + 67),
    LVM_SETBKIMAGE  = (LVM_FIRST + 68),
    LVM_GETBKIMAGE  = (LVM_FIRST + 69),
    LVM_GETWORKAREAS  = (LVM_FIRST + 70),
    LVM_SETHOVERTIME  = (LVM_FIRST + 71),
    LVM_GETHOVERTIME  = (LVM_FIRST + 72),
    LVM_GETNUMBEROFWORKAREAS  = (LVM_FIRST + 73),
    LVM_SETTOOLTIPS  = (LVM_FIRST + 74),
    LVM_GETITEMW = (LVM_FIRST + 75),
    LVM_SETITEMW = (LVM_FIRST + 76),  //Unicode
    LVM_INSERTITEMW = (LVM_FIRST + 77), //Unicode
    LVM_GETTOOLTIPS  = (LVM_FIRST + 78),
    LVM_GETHOTLIGHTCOLOR = (LVM_FIRST + 79), //UNDOCUMENTED
    LVM_SETHOTLIGHTCOLOR = (LVM_FIRST + 80), //UNDOCUMENTED
    LVM_SORTITEMSEX  = (LVM_FIRST + 81),
    LVM_SETRANGEOBJECT = (LVM_FIRST + 82), //UNDOCUMENTED
    LVM_FINDITEMW                   = (LVM_FIRST + 83), //Unicode
    LVM_RESETEMPTYTEXT = (LVM_FIRST + 84), //UNDOCUMENTED
    LVM_SETFROZENITEM = (LVM_FIRST + 85), //UNDOCUMENTED
    LVM_GETFROZENITEM = (LVM_FIRST + 86), //UNDOCUMENTED
    LVM_GETSTRINGWIDTHW = (LVM_FIRST + 87),
    LVM_SETFROZENSLOT = (LVM_FIRST + 88), //UNDOCUMENTED
    LVM_GETFROZENSLOT = (LVM_FIRST + 89), //UNDOCUMENTED
    LVM_SETVIEWMARGIN = (LVM_FIRST + 90), //UNDOCUMENTED
    LVM_GETVIEWMARGIN = (LVM_FIRST + 91), //UNDOCUMENTED
    LVM_GETGROUPSTATE = (LVM_FIRST + 92),
    LVM_GETFOCUSEDGROUP = (LVM_FIRST + 93),
    LVM_EDITGROUPLABEL = (LVM_FIRST + 94), //UNDOCUMENTED
    LVM_GETCOLUMNW                 = (LVM_FIRST + 95), //Unicode
    LVM_SETCOLUMNW                 = (LVM_FIRST + 96), //Unicode
    LVM_INSERTCOLUMNW              = (LVM_FIRST + 97), //Unicode
    LVM_GETGROUPRECT              = (LVM_FIRST + 98),

    LVM_GETITEMTEXTW = (LVM_FIRST + 115),     //Unicode
    LVM_SETITEMTEXTW = (LVM_FIRST + 116),           //Unicode
    LVM_GETISEARCHSTRINGW = (LVM_FIRST + 117),
    LVM_EDITLABELW = (LVM_FIRST + 118),

    LVM_SETBKIMAGEW = (LVM_FIRST + 138),
    LVM_GETBKIMAGEW = (LVM_FIRST + 139),
    LVM_SETSELECTEDCOLUMN = (LVM_FIRST + 140),
    LVM_SETTILEWIDTH = (LVM_FIRST + 141),
    LVM_SETVIEW  = (LVM_FIRST + 142),
    LVM_GETVIEW  = (LVM_FIRST + 143),

    LVM_INSERTGROUP = (LVM_FIRST + 145),

    LVM_SETGROUPINFO = (LVM_FIRST + 147),

    LVM_GETGROUPINFO = (LVM_FIRST + 149),
    LVM_REMOVEGROUP = (LVM_FIRST + 150),
    LVM_MOVEGROUP = (LVM_FIRST + 151),
    LVM_GETGROUPCOUNT             = (LVM_FIRST + 152),
    LVM_GETGROUPINFOBYINDEX       = (LVM_FIRST + 153),
    LVM_MOVEITEMTOGROUP = (LVM_FIRST + 154),
    LVM_SETGROUPMETRICS = (LVM_FIRST + 155),
    LVM_GETGROUPMETRICS = (LVM_FIRST + 156),
    LVM_ENABLEGROUPVIEW = (LVM_FIRST + 157),
    LVM_SORTGROUPS = (LVM_FIRST + 158),
    LVM_INSERTGROUPSORTED = (LVM_FIRST + 159),
    LVM_REMOVEALLGROUPS = (LVM_FIRST + 160),
    LVM_HASGROUP = (LVM_FIRST + 161),
    LVM_SETTILEVIEWINFO = (LVM_FIRST + 162),
    LVM_GETTILEVIEWINFO = (LVM_FIRST + 163),
    LVM_SETTILEINFO = (LVM_FIRST + 164),
    LVM_GETTILEINFO = (LVM_FIRST + 165),
    LVM_SETINSERTMARK = (LVM_FIRST + 166),
    LVM_GETINSERTMARK = (LVM_FIRST + 167),
    LVM_INSERTMARKHITTEST = (LVM_FIRST + 168),
    LVM_GETINSERTMARKRECT = (LVM_FIRST + 169),
    LVM_SETINSERTMARKCOLOR = (LVM_FIRST + 170),
    LVM_GETINSERTMARKCOLOR = (LVM_FIRST + 171),

    LVM_SETINFOTIP = (LVM_FIRST + 173),
    LVM_GETSELECTEDCOLUMN = (LVM_FIRST + 174),
    LVM_ISGROUPVIEWENABLED = (LVM_FIRST + 175),
    LVM_GETOUTLINECOLOR = (LVM_FIRST + 176),
    LVM_SETOUTLINECOLOR = (LVM_FIRST + 177),
    LVM_SETKEYBOARDSELECTED = (LVM_FIRST + 178),  //UNDOCUMENTED
    LVM_CANCELEDITLABEL = (LVM_FIRST + 179),
    LVM_MAPINDEXTOID = (LVM_FIRST + 180),
    LVM_MAPIDTOINDEX = (LVM_FIRST + 181),
    LVM_ISITEMVISIBLE = (LVM_FIRST + 182),
    LVM_EDITSUBITEM = (LVM_FIRST + 183),          //UNDOCUMENTED
    LVM_ENSURESUBITEMVISIBLE = (LVM_FIRST + 184), //UNDOCUMENTED
    LVM_GETCLIENTRECT = (LVM_FIRST + 185),        //UNDOCUMENTED
    LVM_GETFOCUSEDCOLUMN = (LVM_FIRST + 186),     //UNDOCUMENTED
    LVM_SETOWNERDATACALLBACK = (LVM_FIRST + 187), //UNDOCUMENTED
    LVM_RECOMPUTEITEMS = (LVM_FIRST + 188),      //UNDOCUMENTED
    LVM_QUERYINTERFACE = (LVM_FIRST + 189),      //UNDOCUMENTED: NOT OFFICIAL NAME
    LVM_SETGROUPSUBSETCOUNT = (LVM_FIRST + 190), //UNDOCUMENTED
    LVM_GETGROUPSUBSETCOUNT = (LVM_FIRST + 191), //UNDOCUMENTED
    LVM_ORDERTOINDEX = (LVM_FIRST + 192),        //UNDOCUMENTED
    LVM_GETACCVERSION = (LVM_FIRST + 193),       //UNDOCUMENTED
    LVM_MAPACCIDTOACCINDEX = (LVM_FIRST + 194),  //UNDOCUMENTED
    LVM_MAPACCINDEXTOACCID = (LVM_FIRST + 195),  //UNDOCUMENTED
    LVM_GETOBJECTCOUNT = (LVM_FIRST + 196),      //UNDOCUMENTED
    LVM_GETOBJECTRECT = (LVM_FIRST + 197),       //UNDOCUMENTED
    LVM_ACCHITTEST = (LVM_FIRST + 198),          //UNDOCUMENTED
    LVM_GETFOCUSEDOBJECT = (LVM_FIRST + 199),    //UNDOCUMENTED
    LVM_GETOBJECTROLE = (LVM_FIRST + 200),       //UNDOCUMENTED
    LVM_GETOBJECTSTATE = (LVM_FIRST + 201),      //UNDOCUMENTED
    LVM_ACCNAVIGATE = (LVM_FIRST + 202),         //UNDOCUMENTED
    LVM_INVOKEDEFAULTACTION = (LVM_FIRST + 203), //UNDOCUMENTED
    LVM_GETEMPTYTEXT = (LVM_FIRST + 204),
    LVM_GETFOOTERRECT = (LVM_FIRST + 205),
    LVM_GETFOOTERINFO = (LVM_FIRST + 206),
    LVM_GETFOOTERITEMRECT = (LVM_FIRST + 207),
    LVM_GETFOOTERITEM = (LVM_FIRST + 208),
    LVM_GETITEMINDEXRECT = (LVM_FIRST + 209),
    LVM_SETITEMINDEXSTATE = (LVM_FIRST + 210),
    LVM_GETNEXTITEMINDEX = (LVM_FIRST + 211),
    LVM_SETPRESERVEALPHA = (LVM_FIRST + 212),    //UNDOCUMENTED

    LVM_SETUNICODEFORMAT = CCM_SETUNICODEFORMAT,
    LVM_GETUNICODEFORMAT = CCM_GETUNICODEFORMAT,

} ListViewMessages;

typedef struct NMLISTVIEW {
    NMHDR   hdr;
    LONG iItem;
    LONG iSubItem;
    LONG uNewState;
    LONG uOldState;
    LONG uChanged;
    POINT ptAction;
    LONG lParam;
} NMLISTVIEW;

typedef enum LVAD_Parts
{
	LVADPART_ITEM = 0x0,
    LVADPART_GROUP = 0x1, //iItem = group id, others unused
    LVADPART_IMAGETITLE = 0x2, //value unconfirmed and purpose unknown
} LVAD_Parts;
typedef enum LVAD_RetFlags
{
    ADRF_DRAWSYNC = 0, //draw synchronously (act same as if LVS_EX_DRAWIMAGEASYNC weren't set)
    ADRF_DRAWNOTHING = 1, //draw nothing (LVADPART_ITEM, LVADPART_GROUP)
    ADRF_DRAWFALLBACK = 2, //draw fallback text (LVADPART_IMAGETITLE)
    ADRF_DRAWIMAGE = 3, //draw image returned in iRetImageIndex instead
} LVAD_RetFlags;
typedef struct NMLVASYNCDRAW {
	NMHDR hdr;
	LONG pimldp;
	LONG hr;
	LVAD_Parts iPart;
	LONG iItem;
	LONG iSubItem;
	LVAD_RetFlags dwRetFlags;
	LONG iRetImageIndex;
} NMLVASYNCDRAW;

typedef enum ListViewKeyFlags {
    LVKF_ALT = 0x0001,
    LVKF_CONTROL = 0x0002,
    LVKF_SHIFT = 0x0004,
} ListViewKeyFlags;

typedef struct NMITEMACTIVATE {
    NMHDR hdr;
    LONG iItem;
    LONG iSubItem;
    LONG uNewState;
    LONG uOldState;
    LONG uChanged;
    POINT ptAction;
    LONG lParam;
    ListViewKeyFlags uKeyFlags;
} NMITEMACTIVATE;
typedef enum LVCD_ItemType
{
    LVCDI_ITEM = 0x0,
    LVCDI_GROUP = 0x1,
    LVCDI_ITEMSLIST = 0x2,
} LVCD_ItemType;
typedef struct NMLVCUSTOMDRAW {
    NMCUSTOMDRAW nmcd;
    LONG clrText;
    LONG clrTextBk;
    LONG iSubItem;
    LVCD_ItemType dwItemType; 
    LONG clrFace;
    short iIconEffect;
    short iIconPhase;
    short iPartId;
    short iStateId;
    RECT rcText;
    LONG uAlign;

} NMLVCUSTOMDRAW;

typedef struct NMLVCACHEHINT {
    NMHDR   hdr;
    LONG iFrom;
    LONG iTo;
} NMLVCACHEHINT;

typedef struct NMLVFINDITEM {
    NMHDR   hdr;
    LONG iStart;
    LVFINDINFO lvfi;
} NMLVFINDITEM;

typedef struct NMLVODSTATECHANGE {
    NMHDR hdr;
    LONG iFrom;
    LONG iTo;
    LONG uNewState;
    LONG uOldState;
} NMLVODSTATECHANGE;

typedef struct NMLVEMPTYMARKUP {
	NMHDR hdr;
	LONG dwFlags;
	WCHAR szMarkup[2084];
} NMLVEMPTYMARKUP;

typedef struct NMLVGROUP {
	NMHDR hdr;
	LONG iGroupId;
	LONG uNewState;
	LONG uOldState;
} NMLVGROUP;

typedef struct NMLVLINK {
	NMHDR hdr;
	LITEM Item;
	LONG iItem;
	LONG iGroupId;
} NMLVLINK;

typedef struct NMLVSCROLL {
	NMHDR hdr;
	LONG dx;
	LONG dy;
} NMLVSCROLL;





typedef enum ListViewNotificationCodes {
  LVN_FIRST = -100,   // &HFFFFFF9C   // (0U-100U),
  LVN_LAST = -199,   // &HFFFFFF39   // (0U-199U),
                                                                          // lParam points to:
  LVN_ITEMCHANGING = (LVN_FIRST - 0),            // NMLISTVIEW, ?, rtn T/F
  LVN_ITEMCHANGED = (LVN_FIRST - 1),             // NMLISTVIEW, ?
  LVN_INSERTITEM = (LVN_FIRST - 2),                  // NMLISTVIEW, iItem
  LVN_DELETEITEM = (LVN_FIRST - 3),                 // NMLISTVIEW, iItem
  LVN_DELETEALLITEMS = (LVN_FIRST - 4),         // NMLISTVIEW, iItem = -1, rtn T/F

  LVN_COLUMNCLICK = (LVN_FIRST - 8),              // NMLISTVIEW, iItem = -1, iSubItem = column
  LVN_BEGINDRAG = (LVN_FIRST - 9),                  // NMLISTVIEW, iItem
  LVN_BEGINRDRAG = (LVN_FIRST - 11),              // NMLISTVIEW, iItem

  LVN_ODCACHEHINT = (LVN_FIRST - 13),           // NMLVCACHEHINT
  LVN_ITEMACTIVATE = (LVN_FIRST - 14),           // v4.70 = NMHDR, v4.71 = NMITEMACTIVATE
  LVN_ODSTATECHANGED = (LVN_FIRST - 15),  // NMLVODSTATECHANGE, rtn T/F
  LVN_HOTTRACK = (LVN_FIRST - 21),                 // NMLISTVIEW, see docs, rtn T/F
  LVN_BEGINLABELEDITA = (LVN_FIRST - 5),        // NMLVDISPINFO, iItem, rtn T/F
  LVN_ENDLABELEDITA = (LVN_FIRST - 6),           // NMLVDISPINFO, see docs
 
  LVN_GETDISPINFOA = (LVN_FIRST - 50),            // NMLVDISPINFO, see docs
  LVN_SETDISPINFOA = (LVN_FIRST - 51),            // NMLVDISPINFO, see docs
  LVN_ODFINDITEMA = (LVN_FIRST - 52),             // NMLVFINDITEM
 
  LVN_KEYDOWN = (LVN_FIRST - 55),                 // NMLVKEYDOWN
  LVN_MARQUEEBEGIN = (LVN_FIRST - 56),       // NMLISTVIEW, rtn T/F
  LVN_GETINFOTIPA = (LVN_FIRST - 57),             // NMLVGETINFOTIP
  LVN_GETINFOTIPW = (LVN_FIRST - 58),              // NMLVGETINFOTIP
  LVN_INCREMENTALSEARCHA = (LVN_FIRST - 62),
  LVN_INCREMENTALSEARCHW = (LVN_FIRST - 63),
  LVN_COLUMNDROPDOWN = (LVN_FIRST - 64),
  LVN_COLUMNOVERFLOWCLICK = (LVN_FIRST - 66),
  LVN_BEGINLABELEDITW = (LVN_FIRST - 75),
  LVN_ENDLABELEDITW = (LVN_FIRST - 76),
  LVN_GETDISPINFOW = (LVN_FIRST - 77),
  LVN_SETDISPINFOW = (LVN_FIRST - 78),
  LVN_ODFINDITEMW = (LVN_FIRST - 79),             // NMLVFINDITEM
  LVN_BEGINSCROLL = (LVN_FIRST - 80),
  LVN_ENDSCROLL = (LVN_FIRST - 81),
  LVN_LINKCLICK = (LVN_FIRST - 84),
  LVN_ASYNCDRAW = (LVN_FIRST - 86), //Undocumented; NMLVASYNCDRAW
  LVN_GETEMPTYMARKUP = (LVN_FIRST - 87),
  LVN_GROUPCHANGED = (LVN_FIRST - 88),   // Undocumented; NMLVGROUP
} ListViewNotificationCodes;

typedef struct NMLVDISPINFO {
    NMHDR hdr;
    LVITEM item;
} NMLVDISPINFO;

typedef struct NMLVKEYDOWN {
    NMHDR hdr;
    short wVKey;
    LONG flags;
} NMLVKEYDOWN;

typedef enum ListViewGetInfoTipFlags {
    LVGIT_UNFOLDED = 0x0001,
} ListViewGetInfoTipFlags;

typedef struct NMLVGETINFOTIP {
    NMHDR hdr;
    ListViewGetInfoTipFlags dwFlags;
    LONG pszText;
    LONG cchTextMax;
    LONG iItem;
    LONG iSubItem;
    LONG lParam;
} NMLVGETINFOTIP;


typedef enum LVGROUPRECT
{
    LVGGR_GROUP = 0,                      //Entire expanded group
    LVGGR_HEADER = 1,                     //Header only (collapsed group)
    LVGGR_LABEL = 2,                     //Label only
    LVGGR_SUBSETLINK = 3,                 //subset link only
} LVGROUPRECT;

typedef enum LVGROUPMETRICFLAGS
{
    LVGMF_NONE = 0,
    LVGMF_BORDERSIZE = 1,
    LVGMF_BORDERCOLOR = 2,
    LVGMF_TEXTCOLOR = 4,
} LVGROUPMETRICFLAGS;

typedef enum LVGROUPMASK
{
     LVGF_NONE = 0,
     LVGF_HEADER = 0x1,
     LVGF_FOOTER = 0x2,
     LVGF_STATE = 0x4,
     LVGF_ALIGN = 0x8,
     LVGF_GROUPID = 0x10,
    // If SO >= WinVista Then
     LVGF_SUBTITLE = 0x100,
     LVGF_TASK = 0x200,
     LVGF_DESCRIPTIONTOP = 0x400,
     LVGF_DESCRIPTIONBOTTOM = 0x800,
     LVGF_TITLEIMAGE = 0x1000,
     LVGF_EXTENDEDIMAGE = 0x2000,
     LVGF_ITEMS = 0x4000,
     LVGF_SUBSET = 0x8000,
     LVGF_SUBSETITEMS = 0x10000,               //readonly, cItems holds count of items in visible subset, iFirstItem is valid
} LVGROUPMASK;

typedef enum LVGROUPSTATE
{
     LVGS_NORMAL = 0x0,
     LVGS_COLLAPSED = 0x1,
     LVGS_HIDDEN = 0x2,
    
    // SO >= WinVista
     LVGS_NOHEADER = 0x4,
     LVGS_COLLAPSIBLE = 0x8,
     LVGS_FOCUSED = 0x10,
     LVGS_SELECTED = 0x20,
     LVGS_SUBSETED = 0x40,
     LVGS_SUBSETLINKFOCUSED = 0x80,
} LVGROUPSTATE;

typedef enum LVGROUPALIGN
{
     LVGA_HEADER_LEFT = 0x1,
     LVGA_HEADER_CENTER = 0x2,
     LVGA_HEADER_RIGHT = 0x4,             // Don//t forget to validate exclusivity
    // SO >= WinVista
     LVGA_FOOTER_LEFT = 0x8,
     LVGA_FOOTER_CENTER = 0x10,
     LVGA_FOOTER_RIGHT = 0x20,             // Don't forget to validate exclusivity
} LVGROUPALIGN;

typedef struct LVGROUP
{
    LONG cbSize;
	LVGROUPMASK Mask;
    LONG pszHeader;
    LONG cchHeader;
    
    LONG pszFooter;
    LONG cchFooter;
    
    LONG iGroupId;
    
   LVGROUPSTATE StateMask;
   LVGROUPSTATE State;
   LVGROUPALIGN uAlign;

    LONG pszSubtitle;
    LONG cchSubtitle;
    LONG pszTask;
    LONG cchTask;
    LONG pszDescriptionTop;
    LONG cchDescriptionTop;
    LONG pszDescriptionBottom;
    LONG cchDescriptionBottom;
    LONG iTitleImage;
    LONG iExtendedImage;
    LONG iFirstItem;    // Read only
    LONG cItems;
    LONG pszSubsetTitle;  // NULL if group is not subset
    LONG cchSubsetTitle;
} LVGROUP;

typedef struct LVINSERTGROUPSORTED
{
    LONG pfnGroupCompare;
    LONG pvData;
    LVGROUP LVG;
} LVINSERTGROUPSORTED;

typedef struct LVGROUPMETRICS
{
    LONG cbSize;
    LVGROUPMETRICFLAGS Mask;
    LONG Left;
    LONG Top;
    LONG Right;
    LONG Bottom;
    LONG crLeft;
    LONG crTop;
    LONG crRigth;
    LONG crBottom;
    LONG crHeader;
    LONG crFooter;
} LVGROUPMETRICS;






// TREEVIEW!!

    [
        dllname("comctl32.dll"),
        helpstring("TreeView")
    ]
    module TreeView {
        const LONG I_CHILDRENCALLBACK = (-1);
		const LONG I_CHILDRENAUTO = (-2);
        const LPSTR WC_TREEVIEW = "SysTreeView32";
    };

typedef enum TreeView_Styles {
    TVS_HASBUTTONS = 0x0001,
    TVS_HASLINES = 0x0002,
    TVS_LINESATROOT = 0x0004,
    TVS_EDITLABELS = 0x0008,
    TVS_DISABLEDRAGDROP = 0x0010,
    TVS_SHOWSELALWAYS = 0x0020,
    TVS_RTLREADING = 0x0040,
    TVS_NOTOOLTIPS = 0x0080,
    TVS_CHECKBOXES = 0x0100,
    TVS_TRACKSELECT = 0x0200,
    TVS_SINGLEEXPAND = 0x0400,
    TVS_INFOTIP = 0x0800,
    TVS_FULLROWSELECT = 0x1000,
    TVS_NOSCROLL = 0x2000,
    TVS_NONEVENHEIGHT = 0x4000,
    TVS_NOHSCROLL = 0x8000,
} TreeView_Styles;

typedef enum TreeView_StylesEx {
    TVS_EX_NOSINGLECOLLAPSE     = 0x0001,
    TVS_EX_MULTISELECT          = 0x0002,
    TVS_EX_DOUBLEBUFFER         = 0x0004,
    TVS_EX_NOINDENTSTATE        = 0x0008,
    TVS_EX_RICHTOOLTIP          = 0x0010,
    TVS_EX_AUTOHSCROLL          = 0x0020,
    TVS_EX_FADEINOUTEXPANDOS    = 0x0040,
    TVS_EX_PARTIALCHECKBOXES    = 0x0080,
    TVS_EX_EXCLUSIONCHECKBOXES  = 0x0100,
    TVS_EX_DIMMEDCHECKBOXES     = 0x0200,
    TVS_EX_DRAWIMAGEASYNC       = 0x0400,
} TreeView_StylesEx;

typedef enum TreeView_ItemFlags {
    TVIF_TEXT = 0x0001,
    TVIF_IMAGE = 0x0002,
    TVIF_PARAM = 0x0004,
    TVIF_STATE = 0x0008,
    TVIF_HANDLE = 0x0010,
    TVIF_SELECTEDIMAGE = 0x0020,
    TVIF_CHILDREN = 0x0040,
    TVIF_INTEGRAL = 0x0080,
	TVIF_STATEEX = 0x0100,
	TVIF_EXPANDEDIMAGE = 0x0200,
    TVIF_DI_SETITEM = 0x1000,
} TreeView_ItemFlags;

typedef enum TreeView_ItemStates {
    TVIS_SELECTED = 0x0002,
    TVIS_CUT = 0x0004,
    TVIS_DROPHILITED = 0x0008,
    TVIS_BOLD = 0x0010,
    TVIS_EXPANDED = 0x0020,
    TVIS_EXPANDEDONCE = 0x0040,
    TVIS_EXPANDPARTIAL = 0x0080,
    TVIS_OVERLAYMASK = 0x0F00,
    TVIS_STATEIMAGEMASK = 0xF000,
    TVIS_USERMASK = 0xF000,
} TreeView_ItemStates;

typedef enum TreeView_ItemStatesEx {
	TVIS_EX_FLAT = 0x0001,
	TVIS_EX_DISABLED = 0x0002,
	TVIS_EX_ALL = 0x0002,
} TreeView_ItemStatesEx;

typedef struct TVITEM {
    TreeView_ItemFlags mask;
    LONG hItem;
    TreeView_ItemStates state;
    TreeView_ItemStates stateMask;
    LONG pszText;
    LONG cchTextMax;
    LONG iImage;
    LONG iSelectedImage;
    LONG cChildren;
    LONG lParam;
} TVITEM;

typedef struct TVITEMEX {
    TreeView_ItemFlags mask;
    LONG hItem;
    TreeView_ItemStates state;
    TreeView_ItemStates stateMask;
    LONG pszText;
    LONG cchTextMax;
    LONG iImage;
    LONG iSelectedImage;
    LONG cChildren;
    LONG lParam;
    LONG iIntegral;
	TreeView_ItemStatesEx uStateEx;
	LONG hwnd;
	LONG iExpandedImage;
	LONG iReserved;
} TVITEMEX;

typedef enum TreeViewSpecialItems {
    TVI_ROOT = 0xFFFF0000,
    TVI_FIRST = 0xFFFF0001,
    TVI_LAST = 0xFFFF0002,
    TVI_SORT = 0xFFFF0003,
} TreeViewSpecialItems;

typedef struct TVINSERTSTRUCTEX {
    LONG hParent;
    LONG hInsertAfter;
    TVITEMEX itemex;
} TVINSERTSTRUCTEX;
typedef struct TVINSERTSTRUCT {
    LONG hParent;
    LONG hInsertAfter;
    TVITEM itemex;
} TVINSERTSTRUCT;

typedef enum TreeViewExpandFlags {
    TVE_COLLAPSE = 0x0001,
    TVE_EXPAND = 0x0002,
    TVE_TOGGLE = 0x0003,
    TVE_EXPANDPARTIAL = 0x4000,
    TVE_COLLAPSERESET = 0x8000,
} TreeViewExpandFlags;

typedef enum TreeViewImageLists {
    TVSIL_NORMAL = 0,
    TVSIL_STATE = 2,
} TreeViewImageLists;

typedef enum TreeViewGetNextFlags {
    TVGN_ROOT = 0x0000,
    TVGN_NEXT = 0x0001,
    TVGN_PREVIOUS = 0x0002,
    TVGN_PARENT = 0x0003,
    TVGN_CHILD = 0x0004,
    TVGN_FIRSTVISIBLE = 0x0005,
    TVGN_NEXTVISIBLE = 0x0006,
    TVGN_PREVIOUSVISIBLE = 0x0007,
    TVGN_DROPHILITE = 0x0008,
    TVGN_CARET = 0x0009,
    TVGN_LASTVISIBLE = 0x000A,
	TVGN_NEXTSELECTED = 0x000B,
} TreeViewGetNextFlags;


typedef enum TreeView_HitTest {
    TVHT_NOWHERE = 0x0001,
    TVHT_ONITEMICON = 0x0002,
    TVHT_ONITEMLABEL = 0x0004,
    TVHT_ONITEM = 0x0007,
    TVHT_ONITEMINDENT = 0x0008,
    TVHT_ONITEMBUTTON = 0x0010,
    TVHT_ONITEMRIGHT = 0x0020,
    TVHT_ONITEMSTATEICON = 0x0040,
    TVHT_ABOVE = 0x0100,
    TVHT_BELOW = 0x0200,
    TVHT_TORIGHT = 0x0400,
    TVHT_TOLEFT = 0x0800,
} TreeViewHitTest;

typedef struct TVHITTESTINFO {
    LONG x;
    LONG y;
    TreeViewHitTest flags;
    LONG hItem;
} TVHITTESTINFO;

typedef enum TreeViewSetGetBorderFlags {
    TVSBF_XBORDER = 0x00000001,
    TVSBF_YBORDER = 0x00000002,
} TreeViewSetGetBorderFlags;

typedef enum TreeView_Messages {
    TVM_INSERTITEM = (0x1100 + 0),
    TVM_INSERTITEMW = (0x1100 + 50),
    TVM_DELETEITEM = (0x1100 + 1),
    TVM_EXPAND = (0x1100 + 2),
    TVM_GETITEMRECT = (0x1100 + 4),
    TVM_GETCOUNT = (0x1100 + 5),
    TVM_GETINDENT = (0x1100 + 6),
    TVM_SETINDENT = (0x1100 + 7),
    TVM_GETIMAGELIST = (0x1100 + 8),
    TVM_SETIMAGELIST = (0x1100 + 9),
    TVM_GETNEXTITEM = (0x1100 + 10),
    TVM_SELECTITEM = (0x1100 + 11),
    TVM_GETITEM = (0x1100 + 12),
    TVM_GETITEMW = (0x1100 + 62),
    TVM_SETITEM = (0x1100 + 13),
    TVM_SETITEMW = (0x1100 + 63),
    TVM_EDITLABEL = (0x1100 + 14),
    TVM_EDITLABELW = (0x1100 + 65),
    TVM_GETEDITCONTROL = (0x1100 + 15),
    TVM_GETVISIBLECOUNT = (0x1100 + 16),
    TVM_HITTEST = (0x1100 + 17),
    TVM_CREATEDRAGIMAGE = (0x1100 + 18),
    TVM_SORTCHILDREN = (0x1100 + 19),
    TVM_ENSUREVISIBLE = (0x1100 + 20),
    TVM_SORTCHILDRENCB = (0x1100 + 21),
    TVM_ENDEDITLABELNOW = (0x1100 + 22),
    TVM_GETISEARCHSTRING = (0x1100 + 23),
    TVM_GETISEARCHSTRINGW = (0x1100 + 64),
    TVM_SETTOOLTIPS = (0x1100 + 24),
    TVM_GETTOOLTIPS = (0x1100 + 25),
    TVM_SETINSERTMARK = (0x1100 + 26),
    TVM_SETITEMHEIGHT = (0x1100 + 27),
    TVM_GETITEMHEIGHT = (0x1100 + 28),
    TVM_SETBKCOLOR = (0x1100 + 29),
    TVM_SETTEXTCOLOR = (0x1100 + 30),
    TVM_GETBKCOLOR = (0x1100 + 31),
    TVM_GETTEXTCOLOR = (0x1100 + 32),
    TVM_SETSCROLLTIME = (0x1100 + 33),
    TVM_GETSCROLLTIME = (0x1100 + 34),
    TVM_SETBORDER = (0x1100 + 35),
    TVM_GETBORDER = (0x1100 + 36),
    TVM_GETITEMSTATE = (0x1100 + 39),
    TVM_SETLINECOLOR = (0x1100 + 40),
    TVM_GETLINECOLOR = (0x1100 + 41),
    TVM_MAPACCIDTOHTREEITEM = (0x1100 + 42),
    TVM_MAPHTREEITEMTOACCID = (0x1100 + 43),
    TVM_SETEXTENDEDSTYLE = (0x1100 + 44),
    TVM_GETEXTENDEDSTYLE = (0x1100 + 45),
    TVM_SETHOT = (0x1100 + 58),
    TVM_SETAUTOSCROLLINFO = (0x1100 + 59),
    TVM_GETSELECTEDCOUNT = (0x1100 + 70),
    TVM_SHOWINFOTIP = (0x1100 + 71),
    TVM_GETITEMPARTRECT = (0x1100 + 72),
} TreeViewMessages;

typedef struct TVSORTCB {
    LONG hParent;
    LONG lpfnCompare;
    LONG lParam;
} TVSORTCB;

typedef enum TVITEMPART
{
    TVGIPR_BUTTON  = 0x0001,
} TVITEMPART;
typedef struct TVGETITEMPARTRECTINFO {
    LONG hti;
    LONG prc;
    TVITEMPART partID;
} TVGETITEMPARTRECTINFO;

typedef struct NMTREEVIEW {
    NMHDR    hdr;
    LONG action;
    TVITEM itemOld;
    TVITEM itemNew;
    POINT ptDrag;
} NMTREEVIEW;

typedef enum TreeView_ChangedFlags {
    TVC_UNKNOWN = 0x0000,
    TVC_BYMOUSE = 0x0001,
    TVC_BYKEYBOARD = 0x0002,
} TreeViewChangedFlags;

typedef struct TVDISPINFO {
    NMHDR hdr;
    TVITEM item;
} TVDISPINFO;
typedef struct TVDISPINFOEX {
	NMHDR hdr;
	TVITEMEX item;
} TVDISPINFOEX;


typedef enum TreeViewNotificationCodes {

    TVN_SELCHANGING = (-400-1),
    TVN_SELCHANGINGW = (-400-50),
    TVN_SELCHANGED = (-400-2),
    TVN_SELCHANGEDW = (-400-51),
    TVN_GETDISPINFO = (-400-3),
    TVN_GETDISPINFOW = (-400-52),
    TVN_SETDISPINFO = (-400-4),
    TVN_SETDISPINFOW = (-400-53),
    TVN_ITEMEXPANDING = (-400-5),
    TVN_ITEMEXPANDINGW = (-400-54),
    TVN_ITEMEXPANDED = (-400-6),
    TVN_ITEMEXPANDEDW = (-400-55),
    TVN_BEGINDRAG = (-400-7),
    TVN_BEGINDRAGW = (-400-56),
    TVN_BEGINRDRAG = (-400-8),
    TVN_BEGINRDRAGW = (-400-57),
    TVN_DELETEITEM = (-400-9),
    TVN_DELETEITEMW = (-400-58),
    TVN_BEGINLABELEDIT = (-400-10),
    TVN_BEGINLABELEDITW = (-400-59),
    TVN_ENDLABELEDIT = (-400-11),
    TVN_ENDLABELEDITW = (-400-60),
    TVN_KEYDOWN = (-400-12),
    TVN_GETINFOTIP = (-400-13),
    TVN_GETINFOTIPW = (-400-14),
    TVN_SINGLEEXPAND = (-400-15),
    TVN_ITEMCHANGINGA = (-400 - 16),
    TVN_ITEMCHANGINGW = (-400 - 17),
    TVN_ITEMCHANGEDA = (-400 - 18),
    TVN_ITEMCHANGEDW = (-400 - 19),
    TVN_ASYNCDRAW = (-400 - 20),
} TreeViewNotificationCodes;

typedef enum TreeViewNotificationReturnValues {
    TVNRET_DEFAULT = 0,
    TVNRET_SKIPOLD = 1,
    TVNRET_SKIPNEW = 2,
    TVCDRF_NOIMAGES = 0x00010000,
 } TreeViewNotificationReturnValues;

typedef struct NMTVKEYDOWN {
    NMHDR hdr;
    short wVKey;
    LONG flags;
} NMTVKEYDOWN;

typedef struct NMTVCUSTOMDRAW {
    NMCUSTOMDRAW nmcd;
    LONG clrText;
    LONG clrTextBk;
    LONG iLevel;
} NMTVCUSTOMDRAW;

typedef struct NMTVGETINFOTIP {
    NMHDR hdr;
    LONG pszText;
    LONG cchTextMax;
    LONG hItem;
    LONG lParam;
} NMTVGETINFOTIP;

typedef struct NMTVITEMCHANGE {
    NMHDR hdr;
    LONG uChanged;
    LONG hItem;
    LONG uStateNew;
    LONG uStateOld;
    LONG lParam;
} NMTVITEMCHANGE;
typedef struct NMTVASYNCDRAW
{
    NMHDR     hdr;
    IMAGELISTDRAWPARAMS pimldp;    // the draw that failed
    LONG   hr;                   // why it failed
    LONG hItem;                // item that failed to draw icon
    LONG    lParam;               // its data
    // Out Params
    LONG     dwRetFlags;           // What listview should do on return
    int       iRetImageIndex;       // used if ADRF_DRAWIMAGE is returned
} NMTVASYNCDRAW;

////////////////////  ComboBoxEx ////////////////////////////////

    [
        helpstring("ComboBoxEx Control")
    ]
    module ComboBoxEx {
        const LPSTR WC_COMBOBOXEX = "ComboBoxEx32";
        const short CBEMAXSTRLEN = 260;
    }

    typedef enum ComboBoxExItemFlags {
        CBEIF_TEXT = 0x00000001,
        CBEIF_IMAGE = 0x00000002,
        CBEIF_SELECTEDIMAGE = 0x00000004,
        CBEIF_OVERLAY = 0x00000008,
        CBEIF_INDENT = 0x00000010,
        CBEIF_LPARAM = 0x00000020,
        CBEIF_DI_SETITEM = 0x10000000,
    } ComboBoxExItemFlags;

    typedef struct COMBOBOXEXITEM {
        ComboBoxExItemFlags mask;
        LONG iItem;
        LONG pszText;
        LONG cchTextMax;
        LONG iImage;
        LONG iSelectedImage;
        LONG iOverlay;
        LONG iIndent;
        LONG lParam;
    } COMBOBOXEXITEM;

    typedef enum ComboBoxExMessages {
        CBEM_INSERTITEM = (0x400 + 1),
        CBEM_SETIMAGELIST = (0x400 + 2),
        CBEM_GETIMAGELIST = (0x400 + 3),
        CBEM_GETITEM = (0x400 + 4),
        CBEM_SETITEM = (0x400 + 5),
        CBEM_DELETEITEM = 0x144,
        CBEM_GETCOMBOCONTROL = (0x400 + 6),
        CBEM_GETEDITCONTROL = (0x400 + 7),
        CBEM_SETEXSTYLE = (0x400 + 8),
        CBEM_SETEXTENDEDSTYLE = (0x400 + 14),
        CBEM_GETEXTENDEDSTYLE = (0x400 + 9),
        CBEM_HASEDITCHANGED = (0x400 + 10),
        CBEM_INSERTITEMW = (0x400 + 11),
        CBEM_SETITEMW = (0x400 + 12),
        CBEM_GETITEMW = (0x400 + 13),
		CBEM_SETUNICODEFORMAT  = CCM_SETUNICODEFORMAT,
		CBEM_GETUNICODEFORMAT  = CCM_GETUNICODEFORMAT,
		CBEM_SETWINDOWTHEME    = CCM_SETWINDOWTHEME,
    } ComboBoxExMessages;

    typedef enum ComboBoxExExtendedStyles {
        CBES_EX_NOEDITIMAGE = 0x00000001,
        CBES_EX_NOEDITIMAGEINDENT = 0x00000002,
        CBES_EX_PATHWORDBREAKPROC = 0x00000004,
        CBES_EX_NOSIZELIMIT = 0x00000008,
        CBES_EX_CASESENSITIVE = 0x00000010,
		CBES_EX_TEXTENDELLIPSIS = 0x00000020,
    } ComboBoxExExtendedStyles;

    typedef struct NMCOMBOBOXEX {
        NMHDR hdr;
        COMBOBOXEXITEM ceItem;
    } NMCOMBOBOXEX;

    typedef enum ComboBoxExNotificationCodes {
        CBEN_GETDISPINFO = (-800 - 0),
        CBEN_GETDISPINFOW = (-800 - 7),
        CBEN_INSERTITEM = (-800 - 1),
        CBEN_DELETEITEM = (-800 - 2),
        CBEN_BEGINEDIT = (-800 - 4),
        CBEN_ENDEDIT = (-800 - 5),
        CBEN_ENDEDITW = (-800 - 6),
        CBEN_DRAGBEGIN = (-800 - 8),
        CBEN_DRAGBEGINW = (-800 - 9),
    } ComboBoxExNotificationCodes;

    typedef enum ComboBoxExEndEditFlags {
        CBENF_KILLFOCUS = 1,
        CBENF_RETURN = 2,
        CBENF_ESCAPE = 3,
        CBENF_DROPDOWN = 4,
    } ComboBoxExEndEditFlags;

 // CBEN_DRAGBEGIN sends this information ...

    typedef struct NMCBEDRAGBEGINW {
        NMHDR hdr;
        LONG iItemid;
        BYTE szText[260 * 2];
    } NMCBEDRAGBEGINW;

    typedef struct NMCBEDRAGBEGIN {
        NMHDR hdr;
        LONG iItemid;
        BYTE szText[260];
    } NMCBEDRAGBEGIN;

    typedef struct NMCBEENDEDITW {
        NMHDR hdr;
        BOOL fChanged;
        LONG iNewSelection;
        BYTE szText[260 * 2];
        LONG iWhy;
    } NMCBEENDEDITW;

    typedef struct NMCBEENDEDIT {
        NMHDR hdr;
        BOOL fChanged;
        LONG iNewSelection;
        BYTE szText[260];
        LONG iWhy;
    } NMCBEENDEDIT;

// = ===== TAB CONTROL = ======

    [
        helpstring("TabControl")
    ]
    module TabControl {
        const LPSTR WC_TABCONTROLA = "SysTabControl32";
		const LPWSTR WC_TABCONTROLW = "SysTabControl32";
    }

    typedef enum TabStyles {
        TCS_SCROLLOPPOSITE = 0x0001, // assumes multiline tab
        TCS_BOTTOM = 0x0002,
        TCS_RIGHT = 0x0002,
        TCS_MULTISELECT = 0x0004, // allow multi-select in button mode
        TCS_FLATBUTTONS = 0x0008,
        TCS_FORCEICONLEFT = 0x0010,
        TCS_FORCELABELLEFT = 0x0020,
        TCS_HOTTRACK = 0x0040,
        TCS_VERTICAL = 0x0080,
        TCS_TABS = 0x0000,
        TCS_BUTTONS = 0x0100,
        TCS_SINGLELINE = 0x0000,
        TCS_MULTILINE = 0x0200,
        TCS_RIGHTJUSTIFY = 0x0000,
        TCS_FIXEDWIDTH = 0x0400,
        TCS_RAGGEDRIGHT = 0x0800,
        TCS_FOCUSONBUTTONDOWN = 0x1000,
        TCS_OWNERDRAWFIXED = 0x2000,
        TCS_TOOLTIPS = 0x4000,
        TCS_FOCUSNEVER = 0x8000,
    } TabStyles;

    typedef enum TabExStyles {
 // EX styles for use with TCM_SETEXTENDEDSTYLE
        TCS_EX_FLATSEPARATORS = 0x00000001,
        TCS_EX_REGISTERDROP = 0x00000002,
    } TabExStyles;

    typedef enum TabItemState {
        TCIS_BUTTONPRESSED = 0x0001,
        TCIS_HIGHLIGHTED = 0x0002,
    } TabItemState;

    typedef enum TabItemFlags {
        TCIF_TEXT = 0x0001,
        TCIF_IMAGE = 0x0002,
        TCIF_RTLREADING = 0x0004,
        TCIF_PARAM = 0x0008,
        TCIF_STATE = 0x0010,
    } TabItemFlags;

    typedef struct TCITEMHEADER {
        TabItemFlags mask;
        LONG lpReserved1;
        LONG lpReserved2;
        LONG pszText;
        LONG cchTextMax;
        LONG iImage;
    } TCITEMHEADER;

    typedef struct TCITEM {
        TabItemFlags mask;
        TabItemState dwState;
        TabItemState dwStateMask;
        LONG pszText;
        LONG cchTextMax;
        LONG iImage;
        LONG lParam;
    } TCITEM;

    typedef enum TabHitTestFlags {
        TCHT_NOWHERE = 0x0001,
        TCHT_ONITEMICON = 0x0002,
        TCHT_ONITEMLABEL = 0x0004,
        TCHT_ONITEM = (TCHT_ONITEMICON | TCHT_ONITEMLABEL)
    } TabHitTestFlags;

    typedef struct TCHITTESTINFO {
        POINT pt;
        TabHitTestFlags flags;
    } TCHITTESTINFO;

    typedef enum TabMessages {
        [helpstring("SNDMSG(hwnd, TCM_GETIMAGELIST, 0, 0)")]
        TCM_GETIMAGELIST = (0x1300 + 2),
        [helpstring("SNDMSG(hwnd, TCM_SETIMAGELIST, 0, himl)")]
        TCM_SETIMAGELIST = (0x1300 + 3),
        [helpstring("SNDMSG(hwnd, TCM_GETITEMCOUNT, 0, 0L)")]
        TCM_GETITEMCOUNT = (0x1300 + 4),
        [helpstring("SNDMSG(hwnd, TCM_GETITEM, iItem, TC_ITEM *pitem)")]
        TCM_GETITEM = (0x1300 + 5),
        [helpstring("SNDMSG(hwnd, TCM_GETITEM, iItem, TC_ITEM *pitem)")]
        TCM_GETITEMW = (0x1300 + 60),
        [helpstring("SNDMSG(hwnd, TCM_SETITEM, iItem, TC_ITEM *pitem)")]
        TCM_SETITEM = (0x1300 + 6),
        [helpstring("SNDMSG(hwnd, TCM_SETITEM, iItem, TC_ITEM *pitem)")]
        TCM_SETITEMW = (0x1300 + 61),
        [helpstring("SNDMSG(hwnd, TCM_INSERTITEM, iItem, TC_ITEM *pitem)")]
        TCM_INSERTITEM = (0x1300 + 7),
        [helpstring("SNDMSG(hwnd, TCM_INSERTITEM, iItem, TC_ITEM *pitem)")]
        TCM_INSERTITEMW = (0x1300 + 62),
        [helpstring("SNDMSG((hwnd), TCM_DELETEITEM, iItem, 0)")]
        TCM_DELETEITEM = (0x1300 + 8),
        TCM_DELETEALLITEMS = (0x1300 + 9),
        [helpstring("SNDMSG((hwnd), TCM_GETITEMRECT, iItem, RECT *prc)")]
        TCM_GETITEMRECT = (0x1300 + 10),
        TCM_GETCURSEL = (0x1300 + 11),
        TCM_SETCURSEL = (0x1300 + 12),
        [helpstring("SNDMSG(hwnd, TCM_HITTEST, 0, TC_HITTESTINFO *pinfo)")]
        TCM_HITTEST = (0x1300 + 13),
        TCM_SETITEMEXTRA = (0x1300 + 14),
        TCM_ADJUSTRECT = (0x1300 + 40),
        TCM_SETITEMSIZE = (0x1300 + 41),
        TCM_REMOVEIMAGE = (0x1300 + 42),
        TCM_SETPADDING = (0x1300 + 43),
        TCM_GETROWCOUNT = (0x1300 + 44),
        TCM_GETTOOLTIPS = (0x1300 + 45),
        TCM_SETTOOLTIPS = (0x1300 + 46),
        TCM_GETCURFOCUS = (0x1300 + 47),
        TCM_SETCURFOCUS = (0x1300 + 48),
        TCM_SETMINTABWIDTH = (0x1300 + 49),
        TCM_DESELECTALL = (0x1300 + 50),
        TCM_HIGHLIGHTITEM = (0x1300 + 51),
        TCM_SETEXTENDEDSTYLE = (0x1300 + 52), // optional wParam = = mask
        TCM_GETEXTENDEDSTYLE = (0x1300 + 53),
		TCM_SETUNICODEFORMAT = CCM_SETUNICODEFORMAT,
		TCM_GETUNICODEFORMAT = CCM_GETUNICODEFORMAT,
    } TabMessages;

    typedef struct NMTCKEYDOWN {
        NMHDR hdr;
        short wVKey;
        LONG flags;
    } NMTCKEYDOWN;

    typedef enum TabNotifications {
        TCN_KEYDOWN = (-550 - 0),
        TCN_SELCHANGE = (-550 - 1),
        TCN_SELCHANGING = (-550 - 2),
        TCN_GETOBJECT = (-550 - 3),
    } TabNotifications;

 // = ===== ANIMATE CONTROL = =============

    typedef enum AnimateStyles {
        ACS_CENTER = 0x0001,
        ACS_TRANSPARENT = 0x0002,
        ACS_AUTOPLAY = 0x0004,
        ACS_TIMER = 0x0008, // don't use threads... use timers
    } AnimateStyles;

    typedef enum AnimateMessages {
        ACM_OPENA = (0x400+100),
        ACM_OPENW = (0x400+103),
        ACM_PLAY = (0x400+101),
        ACM_STOP = (0x400+102),
    } AnimateMessages;

    typedef enum AnimateNotificationCodes {
        ACN_START = 1,
        ACN_STOP = 2,
    } AnimateNotificationCodes;

    [
        helpstring("Animate Control"),
        dllname("user32.dll")
    ]
    module Animate {
        const LPSTR ANIMATE_CLASS = "SysAnimate32";
    }


// = ===== MONTHCAL CONTROL = =========

    [
        dllname("comctl32.dll")
    ]
    module MonthCal {

        const LPSTR MONTHCAL_CLASS = "SysMonthCal32";
    }

    typedef enum MCSC_Flags {
        MCSC_BACKGROUND = 0, // the background color (between months)
        MCSC_TEXT = 1, // the dates
        MCSC_TITLEBK = 2, // background of the title
        MCSC_TITLETEXT = 3,
        MCSC_MONTHBK = 4, // background within the month cal
        MCSC_TRAILINGTEXT = 5, // the text color of header & trailing days
    } MonthCalSetColorFlags;

    typedef struct MCHITTESTINFO {
        LONG cbSize;
        POINT pt;
        LONG uHit; // out param
        SYSTEMTIME st;
		RECT rc;
		LONG iOffset;
		LONG iRow;
		LONG iCol;
    } MCHITTESTINFO;

    typedef enum MCHT_Flags {
        MCHT_TITLE = 0x00010000,
        MCHT_CALENDAR = 0x00020000,
        MCHT_TODAYLINK = 0x00030000,

        MCHT_NEXT = 0x01000000, // these indicate that hitting
        MCHT_PREV = 0x02000000, // here will go to the next/prev month

        MCHT_NOWHERE = 0x00000000,

        MCHT_TITLEBK = (MCHT_TITLE),
        MCHT_TITLEMONTH = (MCHT_TITLE | 0x0001),
        MCHT_TITLEYEAR = (MCHT_TITLE | 0x0002),
        MCHT_TITLEBTNNEXT = (MCHT_TITLE | MCHT_NEXT | 0x0003),
        MCHT_TITLEBTNPREV = (MCHT_TITLE | MCHT_PREV | 0x0003),

        MCHT_CALENDARBK = (MCHT_CALENDAR),
        MCHT_CALENDARDATE = (MCHT_CALENDAR | 0x0001),
        MCHT_CALENDARDATENEXT = (MCHT_CALENDARDATE | MCHT_NEXT),
        MCHT_CALENDARDATEPREV = (MCHT_CALENDARDATE | MCHT_PREV),
        MCHT_CALENDARDAY = (MCHT_CALENDAR | 0x0002),
        MCHT_CALENDARWEEKNUM = (MCHT_CALENDAR | 0x0003),
		MCHT_CALENDARCONTROL = 0x00100000,
		MCHT_CALENDARDATEMIN = (MCHT_CALENDAR | 0x0004),
		MCHT_CALENDARDATEMAX = (MCHT_CALENDAR | 0x0005),
    } MonthCalHitTestFlags;

    typedef enum MonthCalMessages {

        MCM_FIRST = 0x1000,

 // BOOL MonthCal_GetCurSel(LONG hmc, LPSYSTEMTIME pst)
 //   returns FALSE if MCS_MULTISELECT
 //   returns TRUE and sets *pst to the currently selected date otherwise

        MCM_GETCURSEL = (MCM_FIRST + 1),

 // BOOL MonthCal_SetCurSel(LONG hmc, LPSYSTEMTIME pst)
 //   returns FALSE if MCS_MULTISELECT
 //   returns TURE and sets the currently selected date to *pst otherwise

        MCM_SETCURSEL = (MCM_FIRST + 2),

 // LONG MonthCal_GetMaxSelCount(LONG hmc)
 //   returns the maximum number of selectable days allowed

        MCM_GETMAXSELCOUNT = (MCM_FIRST + 3),

 // BOOL MonthCal_SetMaxSelCount(LONG hmc, LONG n)
 //   sets the max number days that can be selected iff MCS_MULTISELECT

        MCM_SETMAXSELCOUNT = (MCM_FIRST + 4),

 // BOOL MonthCal_GetSelRange(LONG hmc, LPSYSTEMTIME rgst)
 //   sets rgst[0] to the first day of the selection range
 //   sets rgst[1] to the last day of the selection range

        MCM_GETSELRANGE = (MCM_FIRST + 5),

 // BOOL MonthCal_SetSelRange(LONG hmc, LPSYSTEMTIME rgst)
 //   selects the range of days from rgst[0] to rgst[1]

        MCM_SETSELRANGE = (MCM_FIRST + 6),

 // LONG MonthCal_GetMonthRange(LONG hmc, LONG gmr, LPSYSTEMTIME rgst)
 //   if rgst specified, sets rgst[0] to the starting date and
 //      and rgst[1] to the ending date of the the selectable (non-grayed)
 //      days if GMR_VISIBLE or all the displayed days (including grayed)
 //      if GMR_DAYSTATE.
 //   returns the number of months spanned by the above range.

        MCM_GETMONTHRANGE = (MCM_FIRST + 7),

 // BOOL MonthCal_SetDayState(LONG hmc, LONG cbds, DAYSTATE *rgds)
 // cbds is the count of DAYSTATE items in rgds and it must be equal
 // to the value returned from MonthCal_GetMonthRange(hmc, GMR_DAYSTATE, NULL)
 //   This sets the DAYSTATE bits for each month (grayed and non-grayed
 //   days) displayed in the calendar. The first bit in a month's DAYSTATE
 //   corresponts to bolding day 1, the second bit affects day 2, etc.

        MCM_SETDAYSTATE = (MCM_FIRST + 8),

 // BOOL MonthCal_GetMinReqRect(LONG hmc, LPRECT prc)
 //   sets *prc the minimal size needed to display one month
 //   To display two months, undo the AdjustWindowRect calculation already done to
 //   this rect, double the width, and redo the AdjustWindowRect calculation --
 //   the monthcal control will display two calendars in this window (if you also
 //   double the vertical size, you will get 4 calendars)
 //   NOTE: if you want to gurantee that the "Today" string is not clipped,
 //   get the MCM_GETMAXTODAYWIDTH and use the max of that width and this width

        MCM_GETMINREQRECT = (MCM_FIRST + 9),

 // set colors to draw control with -- see MCSC_ bits below

        MCM_SETCOLOR = (MCM_FIRST + 10),

        MCM_GETCOLOR = (MCM_FIRST + 11),

 // set what day is "today"   send NULL to revert back to real date

        MCM_SETTODAY = (MCM_FIRST + 12),

 // get what day is "today"
 // returns BOOL for success/failure

        MCM_GETTODAY = (MCM_FIRST + 13),

 // determine what pinfo->pt is over

        MCM_HITTEST = (MCM_FIRST + 14),

 // set first day of week to iDay:
 // 0 for Monday, 1 for Tuesday, ..., 6 for Sunday
 // -1 for means use locale info
        MCM_SETFIRSTDAYOFWEEK = (MCM_FIRST + 15),

 // LONG result...  low word has the day.  high word is bool if this is app set
 // or not (FALSE = = using locale info)

        MCM_GETFIRSTDAYOFWEEK = (MCM_FIRST + 16),

 // LONG MonthCal_GetRange(LONG hmc, LPSYSTEMTIME rgst)
 //   modifies rgst[0] to be the minimum ALLOWABLE systemtime (or 0 if no minimum)
 //   modifies rgst[1] to be the maximum ALLOWABLE systemtime (or 0 if no maximum)
 //   returns GDTR_MIN|GDTR_MAX if there is a minimum|maximum limit

        MCM_GETRANGE = (MCM_FIRST + 17),

 // BOOL MonthCal_SetRange(LONG hmc, LONG gdtr, LPSYSTEMTIME rgst)
 //   if GDTR_MIN, sets the minimum ALLOWABLE systemtime to rgst[0], otherwise removes minimum
 //   if GDTR_MAX, sets the maximum ALLOWABLE systemtime to rgst[1], otherwise removes maximum
 //   returns TRUE on success, FALSE on error (such as invalid parameters)

        MCM_SETRANGE = (MCM_FIRST + 18),

 // LONG MonthCal_GetMonthDelta(LONG hmc)
 //   returns the number of months one click on a next/prev button moves by

        MCM_GETMONTHDELTA = (MCM_FIRST + 19),

 // LONG MonthCal_SetMonthDelta(LONG hmc, LONG n)
 //   sets the month delta to n. n = = 0 reverts to moving by a page of months
 //   returns the previous value of n.

        MCM_SETMONTHDELTA = (MCM_FIRST + 20),

 // LONG MonthCal_GetMaxTodayWidth(LONG hmc, LPSIZE psz)
 //   sets *psz to the maximum width/height of the "Today" string displayed
 //   at the bottom of the calendar (as long as MCS_NOTODAY is not specified)

        MCM_GETMAXTODAYWIDTH = (MCM_FIRST + 21),

		MCM_GETCURRENTVIEW = (MCM_FIRST + 22),
		MCM_GETCALENDARCOUNT = (MCM_FIRST + 23),
		MCM_GETCALENDARGRIDINFO = (MCM_FIRST + 24),

		MCM_GETCALID = (MCM_FIRST + 27),
		MCM_SETCALID = (MCM_FIRST + 28),
		MCM_SIZERECTTOMIN = (MCM_FIRST + 29),
		MCM_SETCALENDARBORDER = (MCM_FIRST + 30),
		MCM_GETCALENDARBORDER = (MCM_FIRST + 31),
		MCM_SETCURRENTVIEW = (MCM_FIRST + 32),
    } MonthCalMessages;

	typedef enum MonthCalView {
		MCMV_MONTH = 0,
		MCMV_YEAR = 1,
		MCMV_DECADE = 2,
		MCMV_CENTURY = 3,
		MCMV_MAX = 3,
	} MonthCalView;

	typedef enum MonthCalGridInfoPart {
		MCGIP_CALENDARCONTROL    = 0,
		MCGIP_NEXT               = 1,
		MCGIP_PREV               = 2,
		MCGIP_FOOTER             = 3,
		MCGIP_CALENDAR           = 4,
		MCGIP_CALENDARHEADER     = 5,
		MCGIP_CALENDARBODY       = 6,
		MCGIP_CALENDARROW        = 7,
		MCGIP_CALENDARCELL       = 8,
	} MonthCalGridInfoPart;

	typedef enum MonthCalGridInfoFlags {
		MCGIF_DATE                = 0x00000001,
		MCGIF_RECT                = 0x00000002,
		MCGIF_NAME                = 0x00000004,
	} MonthCalGridInfoFlags;

// Note: iRow of -1 refers to the row header and iCol of -1 refers to the col header.
typedef struct MCGRIDINFO {
    LONG cbSize;
    MonthCalGridInfoPart dwPart;
    MonthCalGridInfoFlags dwFlags;
    int iCalendar;
    int iRow;
    int iCol;
    BOOL bSelected;
    SYSTEMTIME stStart;
    SYSTEMTIME stEnd;
    RECT rc;
    LONG pszName;
    LONG cchName;
} MCGRIDINFO;

    typedef enum MonthCallNotifications {

 // MCN_SELCHANGE is sent whenever the currently displayed date changes
 // via month change, year change, keyboard navigation, prev/next button
 //

        MCN_SELCHANGE = (-750 + 1),

 // MCN_GETDAYSTATE is sent for MCS_DAYSTATE controls whenever new daystate
 // information is needed (month or year scroll) to draw bolding information.
 // The app must fill in cDayState months worth of information starting from
 // stStart date. The app may fill in the array at prgDayState or change
 // prgDayState to point to a different array out of which the information
 // will be copied. (similar to tooltips)

        MCN_GETDAYSTATE = (-750 + 3),

 // MCN_SELECT is sent whenever a selection has occured (via mouse or keyboard)

        MCN_SELECT = (-750 + 4),

		MCN_VIEWCHANGE = (-750),

    } MonthCallNotifications;

    typedef struct NMSELCHANGE {
        NMHDR       nmhdr;
        SYSTEMTIME      stSelStart;
        SYSTEMTIME      stSelEnd;
    } NMSELCHANGE;

    typedef struct NMDAYSTATE {
        NMHDR      nmhdr;
        SYSTEMTIME stStart;
        LONG cDayState;
        LONG prgDayState; // points to cDayState MONTHDAYSTATEs
    } NMDAYSTATE;

	typedef struct NMVIEWCHANGE
	{
		NMHDR           nmhdr;  // this must be first, so we don't break WM_NOTIFY
		LONG           dwOldView;
		LONG           dwNewView;
	} NMVIEWCHANGE;

    typedef enum MonthCalStyles {
        MCS_DAYSTATE = 0x0001,
        MCS_MULTISELECT = 0x0002,
        MCS_WEEKNUMBERS = 0x0004,
        MCS_NOTODAYCIRCLE = 0x0008,
        MCS_NOTODAY = 0x0010,
		MCS_NOTRAILINGDATES = 0x0040,
		MCS_SHORTDAYSOFWEEK = 0x0080,
		MCS_NOSELCHANGEONNAV = 0x0100,
    } MonthCalStyles;

    typedef enum MonthCalGetMonthRangeFlags {
        GMR_VISIBLE = 0, // visible portion of display
        GMR_DAYSTATE = 1 // above plus the grayed out parts of
 // partially displayed months
    } MonthCalGetMonthRangeFlags;


// = = ====DATETIMEPICK CONTROL = = ================================================

    [
        dllname("comctl32.dll")
    ]
    module DateTimePick {

        const LPSTR DATETIMEPICK_CLASS = "SysDateTimePick32";

    }

	typedef struct tagDATETIMEPICKERINFO
	{
		LONG cbSize;

		RECT rcCheck;
		LONG stateCheck;

		RECT rcButton;
		LONG stateButton;

		LONG hwndEdit;
		LONG hwndUD;
		LONG hwndDropDown;
	} DATETIMEPICKERINFO;

    typedef enum DateTimePickMessages {
        DTM_FIRST = 0x1000,

 // LONG DateTimePick_GetSystemtime(LONG hdp, LPSYSTEMTIME pst)
 //   returns GDT_NONE if "none" is selected (DTS_SHOWNONE only)
 //   returns GDT_VALID and modifies *pst to be the currently selected value
        DTM_GETSYSTEMTIME = (DTM_FIRST + 1),

 // BOOL DateTime_SetSystemtime(LONG hdp, LONG gd, LPSYSTEMTIME pst)
 //   if gd = = GDT_NONE, sets datetimepick to None (DTS_SHOWNONE only)
 //   if gd = = GDT_VALID, sets datetimepick to *pst
 //   returns TRUE on success, FALSE on error (such as bad params)
        DTM_SETSYSTEMTIME = (DTM_FIRST + 2),

 // LONG DateTime_GetRange(LONG hdp, LPSYSTEMTIME rgst)
 //   modifies rgst[0] to be the minimum ALLOWABLE systemtime (or 0 if no minimum)
 //   modifies rgst[1] to be the maximum ALLOWABLE systemtime (or 0 if no maximum)
 //   returns GDTR_MIN|GDTR_MAX if there is a minimum|maximum limit
        DTM_GETRANGE = (DTM_FIRST + 3),

 // BOOL DateTime_SetRange(LONG hdp, LONG gdtr, LPSYSTEMTIME rgst)
 //   if GDTR_MIN, sets the minimum ALLOWABLE systemtime to rgst[0], otherwise removes minimum
 //   if GDTR_MAX, sets the maximum ALLOWABLE systemtime to rgst[1], otherwise removes maximum
 //   returns TRUE on success, FALSE on error (such as invalid parameters)
        DTM_SETRANGE = (DTM_FIRST + 4),

 // BOOL DateTime_SetFormat(LONG hdp, LPCTSTR sz)
 //   sets the display formatting string to sz (see GetDateFormat and GetTimeFormat for valid formatting chars)
 //   NOTE: 'X' is a valid formatting character which indicates that the application
 //   will determine how to display information. Such apps must support DTN_WMKEYDOWN,
 //   DTN_FORMAT, and DTN_FORMATQUERY.
        DTM_SETFORMAT = (DTM_FIRST + 5),
        DTM_SETFORMATW = (DTM_FIRST + 50),

        DTM_SETMCCOLOR = (DTM_FIRST + 6),
        DTM_GETMCCOLOR = (DTM_FIRST + 7),

 // LONG DateTime_GetMonthCal(LONG hdp)
 //   returns the LONG of the MonthCal popup window. Only valid
 // between DTN_DROPDOWN and DTN_CLOSEUP notifications.
        DTM_GETMONTHCAL = (DTM_FIRST + 8),

        DTM_SETMCFONT = (DTM_FIRST + 9),
        DTM_GETMCFONT = (DTM_FIRST + 10),
		DTM_SETMCSTYLE   = (DTM_FIRST + 11),
		DTM_GETMCSTYLE   = (DTM_FIRST + 12),
		DTM_CLOSEMONTHCAL = (DTM_FIRST + 13),
		// DateTime_GetDateTimePickerInfo(HWND hdp, DATETIMEPICKERINFO* pdtpi)
		// Retrieves information about the selected date time picker.
		DTM_GETDATETIMEPICKERINFO = (DTM_FIRST + 14),
		DTM_GETIDEALSIZE = (DTM_FIRST + 15),
    } DateTimePickMessages;

    typedef enum DateTimePickStyles {
        DTS_UPDOWN = 0x0001 , // use UPDOWN instead of MONTHCAL
        DTS_SHOWNONE = 0x0002 , // allow a NONE selection
        DTS_SHORTDATEFORMAT = 0x0000 , // use the short date format (app must forward WM_WININICHANGE messages)
        DTS_LONGDATEFORMAT = 0x0004 , // use the long date format (app must forward WM_WININICHANGE messages)
        DTS_TIMEFORMAT = 0x0009 , // use the time format (app must forward WM_WININICHANGE messages)
        DTS_SHORTDATECENTURYFORMAT = 0x000C, // short date format with century (app must forward WM_WININICHANGE        DTS_APPCANPARSE = 0x0010 , // allow user entered strings (app MUST respond to DTN_USERSTRING)
        DTS_RIGHTALIGN = 0x0020 , // right-align popup instead of left-align it
    } DateTimePickStyles;

    typedef enum DateTimePickNotifications {

        DTN_DATETIMECHANGE = (-760 + 1), // the systemtime has changed
        DTN_USERSTRING = (-760 + 2), // the user has entered a string
        DTN_USERSTRINGW = (-760 + 15),
        DTN_WMKEYDOWN = (-760 + 3), // modify keydown on app format field (X)
        DTN_WMKEYDOWNW = (-760 + 16),
        DTN_FORMATA = (-760 + 4), // query display for app format field (X)
        DTN_FORMATW = (-760 + 17),
        DTN_FORMATQUERYA = (-760 + 5), // query formatting info for app format field (X)
        DTN_FORMATQUERYW = (-760 + 18),
        DTN_DROPDOWN = (-760 + 6), // MonthCal has dropped down
        DTN_CLOSEUP = (-760 + 7), // MonthCal is popping up
    } DateTimePickNotifications;

    typedef enum DateTimePickDateTimeChangeFlags {
        GDT_ERROR = -1,
        GDT_VALID = 0,
        GDT_NONE = 1,
    } DateTimePickDateTimeChangeFlags;

    typedef struct NMDATETIMECHANGE {
        NMHDR       nmhdr;
        DateTimePickDateTimeChangeFlags dwFlags; // GDT_VALID or GDT_NONE
        SYSTEMTIME  st; // valid iff dwFlags = = GDT_VALID
    } NMDATETIMECHANGE;

    typedef struct NMDATETIMESTRING {
        NMHDR      nmhdr;
        LONG pszUserString; // string user entered
        SYSTEMTIME st; // app fills this in
        DateTimePickDateTimeChangeFlags dwFlags; // GDT_VALID or GDT_NONE
    } NMDATETIMESTRING;

    typedef struct NMDATETIMEWMKEYDOWN {
        NMHDR      nmhdr;
        LONG nVirtKey; // virtual key code of WM_KEYDOWN which MODIFIES an X field
        LONG pszFormat; // format substring
        SYSTEMTIME st; // current systemtime, app should modify based on key
    } NMDATETIMEWMKEYDOWN;

    typedef struct NMDATETIMEFORMAT {
        NMHDR      nmhdr;
        LONG pszFormat; // format substring
        SYSTEMTIME st; // current systemtime
        LONG pszDisplay; // string to display
        BYTE       szDisplay[64]; // buffer pszDisplay originally points at
    } NMDATETIMEFORMAT;

    typedef struct NMDATETIMEFORMATW {
        NMHDR nmhdr;
        LONG pszFormat; // format substring
        SYSTEMTIME st; // current systemtime
        LONG pszDisplay; // string to display
        BYTE szDisplay[128]; // buffer pszDisplay originally points at
    } NMDATETIMEFORMATW;

    typedef struct NMDATETIMEFORMATQUERY {
        NMHDR nmhdr;
        LONG pszFormat; // format substring
        SIZE szMax; // max bounding rectangle app will use for this format string
    } NMDATETIMEFORMATQUERY;

    typedef enum DateTimePickGetDateTimeRangeFlags {
        GDTR_MIN = 0x0001,
        GDTR_MAX = 0x0002,
    } DateTimePickGetDateTimeRangeFlags;


///    IP Address edit control

    typedef enum IPAddressMessages {
        IPM_CLEARADDRESS = (0x400+100),// no parameters
        IPM_SETADDRESS = (0x400+101),// lparam = TCP/IP address
        IPM_GETADDRESS = (0x400+102),// lresult = # of non black fields.
 // lparam = LPLONG for TCP/IP address
        IPM_SETRANGE = (0x400+103), // wparam = field, lparam = range
        IPM_SETFOCUS = (0x400+104), // wparam = field
        IPM_ISBLANK = (0x400+105), // no parameters
    } IPAddressMessages;

    typedef enum IPAddressNotificationCodes {
        IPN_FIELDCHANGED = (-860 - 0),
    } IPAddressNotificationCodes;

    typedef struct NMIPADDRESS {
        NMHDR hdr;
        LONG iField;
        LONG iValue;
    } NMIPADDRESS;

    [
        helpstring("IPAddress Control"),
        dllname("comctl32.dll")
    ]
    module IPAddress {
        const LPSTR WC_IPADDRESS = "SysIPAddress32";
    }

// = ===================== Pager Control = ============================

    [
        helpstring("Pager")
    ]
    module Pager {
        const LPSTR WC_PAGESCROLLER = "SysPager";

    }

//---------------------------------------------------------------------------------------
// Pager Control Styles
//---------------------------------------------------------------------------------------
    typedef enum PagerStyles {
        PGS_VERT = 0x0000,
        PGS_HORZ = 0x0001,
        PGS_AUTOSCROLL = 0x00000002,
        PGS_DRAGNDROP = 0x00000004,
    } PagerStyles;

//---------------------------------------------------------------------------------------
// Pager Button State
//---------------------------------------------------------------------------------------
//The scroll can be in one of the following control State
    typedef enum PagerButtonStates {
        PGF_INVISIBLE = 0, // Scroll button is not visible
        PGF_NORMAL = 1, // Scroll button is in normal state
        PGF_GRAYED = 2, // Scroll button is in grayed state
        PGF_DEPRESSED = 4, // Scroll button is in depressed state
        PGF_HOT = 8, // Scroll button is in hot state
    } PagerButtonStates;

    typedef enum PagerButton {
        PGB_TOPORLEFT = 0,
        PGB_BOTTOMORRIGHT = 1,
    } PagerButton ;

//---------------------------------------------------------------------------------------
// Pager Control  Messages
//---------------------------------------------------------------------------------------
    typedef enum PageMessages {

        PGM_SETCHILD = (0x1400 + 1), // lParam = = hwnd
        PGM_RECALCSIZE = (0x1400 + 2),
        PGM_FORWARDMOUSE = (0x1400 + 3),
        PGM_SETBKCOLOR = (0x1400 + 4),
        PGM_GETBKCOLOR = (0x1400 + 5),
        PGM_SETBORDER = (0x1400 + 6),
        PGM_GETBORDER = (0x1400 + 7),
        PGM_SETPOS = (0x1400 + 8),
        PGM_GETPOS = (0x1400 + 9),
        PGM_SETBUTTONSIZE = (0x1400 + 10),
        PGM_GETBUTTONSIZE = (0x1400 + 11),
        PGM_GETBUTTONSTATE = (0x1400 + 12),
		PGM_SETSCROLLINFO  = (0x1400 + 13),
		PGM_GETDROPTARGET = CCM_GETDROPTARGET,
    } PageMessages;

//---------------------------------------------------------------------------------------
//Pager Control Notification Messages
//---------------------------------------------------------------------------------------

    typedef enum PagerNotifications {
        PGN_SCROLL = (-900-1),
        PGN_CALCSIZE = (-900-2),
		PGN_HOTITEMCHANGE = (-900-3),

    } PagerNotifications;

    typedef enum PagerScrollFlags {
        PGF_SCROLLUP = 1,
        PGF_SCROLLDOWN = 2,
        PGF_SCROLLLEFT = 4,
        PGF_SCROLLRIGHT = 8,
    } PagerScrollFlags;

    typedef enum PagerCalcSizeFlags {
        PGF_CALCWIDT = 1,
        PGF_CALCHEIGHT = 2,
    } PagerCalcSizeFlags;

	typedef enum PagerKeyDown {
		PGK_SHIFT = 1,
		PGK_CONTROL = 2,
		PGK_MENU = 3,
	} PagerKeyDown;

    typedef struct NMPGSCROLL {
        NMHDR hdr;
		WORD fwKeys;
        RECT rcParent; // Contains Parent Window Rect
        LONG iDir; // Scrolling Direction
        LONG iXpos; // Horizontal scroll position
        LONG iYpos; // Vertical scroll position
        LONG iScroll; // [in/out] Amount to scroll
    } NMPGSCROLL;

    typedef struct NMPGCALCSIZE {
        NMHDR   hdr;
        LONG dwFlag;
        LONG iWidth;
        LONG iHeight;
    } NMPGCALCSIZE;

	typedef struct NMPGHOTITEM
	{
		NMHDR   hdr;
		int     idOld;
		int     idNew;
		Toolbar_HotItemFlags   dwFlags;           // HICF_*
	} NMPGHOTITEM;

 // === Native Font Control ===

    [
        helpstring("NativeFont")
    ]
    module NativeFont {
        const LPSTR WC_NATIVEFONTCTL = "NativeFontCtl";

    }

    typedef enum NativeFontStyles {
        NFS_EDIT                =0x0001,
        NFS_STATIC              =0x0002,
        NFS_LISTCOMBO           =0x0004,
        NFS_BUTTON              =0x0008,
        NFS_ALL                 =0x0010,
        NFS_USEFONTASSOC        =0x0020,
    } NativeFontStyles;


 // === MUI APIs ===

    [
        dllname("comctl32.dll")
    ]
    module MUIApis {

        [entry("InitMUILanguage")]
        void InitMUILanguage(LONG uiLang);

        [entry("GetMUILanguage")]
        LONG GetMUILanguage(void);
    }

//======= Static Control
    [
        helpstring("StaticControl")
    ]
    module StaticControl {
        const LPSTR WC_STATIC = "Static";

    }

	typedef enum StaticControlStyles {
        SS_LEFT             = 0x00000000,
        SS_CENTER           = 0x00000001,
        SS_RIGHT            = 0x00000002,
        SS_ICON             = 0x00000003,
        SS_BLACKRECT        = 0x00000004,
        SS_GRAYRECT         = 0x00000005,
        SS_WHITERECT        = 0x00000006,
        SS_BLACKFRAME       = 0x00000007,
        SS_GRAYFRAME        = 0x00000008,
        SS_WHITEFRAME       = 0x00000009,
        SS_USERITEM         = 0x0000000A,
        SS_SIMPLE           = 0x0000000B,
        SS_LEFTNOWORDWRAP   = 0x0000000C,
        SS_OWNERDRAW        = 0x0000000D,
        SS_BITMAP           = 0x0000000E,
        SS_ENHMETAFILE      = 0x0000000F,
        SS_ETCHEDHORZ       = 0x00000010,
        SS_ETCHEDVERT       = 0x00000011,
        SS_ETCHEDFRAME      = 0x00000012,
        SS_TYPEMASK         = 0x0000001F,
        SS_REALSIZECONTROL  = 0x00000040,
        SS_NOPREFIX         = 0x00000080, /* Don't do "&" character translation */
        SS_NOTIFY           = 0x00000100,
        SS_CENTERIMAGE      = 0x00000200,
        SS_RIGHTJUST        = 0x00000400,
        SS_REALSIZEIMAGE    = 0x00000800,
        SS_SUNKEN           = 0x00001000,
        SS_EDITCONTROL      = 0x00002000,
        SS_ENDELLIPSIS      = 0x00004000,
        SS_PATHELLIPSIS     = 0x00008000,
        SS_WORDELLIPSIS     = 0x0000C000,
        SS_ELLIPSISMASK     = 0x0000C000,

	} StaticControlStyles;

	typedef enum StaticControlMessages 
	{
        STM_SETICON        = 0x0170,
        STM_GETICON        = 0x0171,
        STM_SETIMAGE       = 0x0172,
        STM_GETIMAGE       = 0x0173,
        STN_CLICKED        = 0,
        STN_DBLCLK         = 1,
        STN_ENABLE         = 2,
        STN_DISABLE        = 3,
        STM_MSGMAX         = 0x0174,
	} StaticControlMessages;


// ======== Edit Control ========

    [
        helpstring("EditControl")
    ]
    module EditControl {
        const LPSTR WC_EDIT = "Edit";

    }
	typedef struct EDITBALLOONTIP
	{
		LONG   cbStruct;
		LONG pszTitle;
		LONG pszText;
		Tooltip_Icon     ttiIcon; // From TTI_*
	} EDITBALLOONTIP;

	typedef enum EditControlMessages {
        EM_GETSEL               = 0x00B0,
        EM_SETSEL               = 0x00B1,
        EM_GETRECT              = 0x00B2,
        EM_SETRECT              = 0x00B3,
        EM_SETRECTNP            = 0x00B4,
        EM_SCROLL               = 0x00B5,
        EM_LINESCROLL           = 0x00B6,
        EM_SCROLLCARET          = 0x00B7,
        EM_GETMODIFY            = 0x00B8,
        EM_SETMODIFY            = 0x00B9,
        EM_GETLINECOUNT         = 0x00BA,
        EM_LINEINDEX            = 0x00BB,
        EM_SETHANDLE            = 0x00BC,
        EM_GETHANDLE            = 0x00BD,
        EM_GETTHUMB             = 0x00BE,
        EM_LINELENGTH           = 0x00C1,
        EM_REPLACESEL           = 0x00C2,
        EM_GETLINE              = 0x00C4,
        EM_LIMITTEXT            = 0x00C5,
        EM_CANUNDO              = 0x00C6,
        EM_UNDO                 = 0x00C7,
        EM_FMTLINES             = 0x00C8,
        EM_LINEFROMCHAR         = 0x00C9,
        EM_SETTABSTOPS          = 0x00CB,
        EM_SETPASSWORDCHAR      = 0x00CC,
        EM_EMPTYUNDOBUFFER      = 0x00CD,
        EM_GETFIRSTVISIBLELINE  = 0x00CE,
        EM_SETREADONLY          = 0x00CF,
        EM_SETWORDBREAKPROC     = 0x00D0,
        EM_GETWORDBREAKPROC     = 0x00D1,
        EM_GETPASSWORDCHAR      = 0x00D2,
        EM_SETMARGINS           = 0x00D3,
        EM_GETMARGINS           = 0x00D4,
        EM_SETLIMITTEXT         = EM_LIMITTEXT,   /* ;win40 Name change */
        EM_GETLIMITTEXT         = 0x00D5,
        EM_POSFROMCHAR          = 0x00D6,
        EM_CHARFROMPOS          = 0x00D7,
        EM_SETIMESTATUS         = 0x00D8,
        EM_GETIMESTATUS         = 0x00D9,
		ECM_FIRST = 0x1500,
		EM_SETCUEBANNER = (ECM_FIRST + 1),
		EM_GETCUEBANNER = (ECM_FIRST + 2),
		EM_SHOWBALLOONTIP = (ECM_FIRST + 3),
		EM_HIDEBALLOONTIP = (ECM_FIRST + 4),
		EM_SETHILITE      = (ECM_FIRST + 5),
		EM_GETHILITE      = (ECM_FIRST + 6),
		EM_NOSETFOCUS     = (ECM_FIRST + 7),
		EM_TAKEFOCUS      = (ECM_FIRST + 8),
	} EditControlMessages;

// ======== ListBox Control =====
    [
        helpstring("ListBox")
    ]
	module ListBox {
        const LPSTR WC_LISTBOX = "ListBox";

    }
	typedef enum ListBoxReturnValues
	{
		LB_OKAY = 0,
		LB_ERR = (-1),
		LB_ERRSPACE = (-2),
	} ListBoxReturnValues;

	typedef enum ListBoxNotifications
	{
		LBN_ERRSPACE       = (-2),
		LBN_SELCHANGE      = 1,
		LBN_DBLCLK         = 2,
		LBN_SELCANCEL      = 3,
		LBN_SETFOCUS       = 4,
		LBN_KILLFOCUS      = 5,
	} ListBoxNotifications;

	typedef enum ListBoxMessages
	{
        LB_ADDSTRING            = 0x0180,
        LB_INSERTSTRING         = 0x0181,
        LB_DELETESTRING         = 0x0182,
        LB_SELITEMRANGEEX       = 0x0183,
        LB_RESETCONTENT         = 0x0184,
        LB_SETSEL               = 0x0185,
        LB_SETCURSEL            = 0x0186,
        LB_GETSEL               = 0x0187,
        LB_GETCURSEL            = 0x0188,
        LB_GETTEXT              = 0x0189,
        LB_GETTEXTLEN           = 0x018A,
        LB_GETCOUNT             = 0x018B,
        LB_SELECTSTRING         = 0x018C,
        LB_DIR                  = 0x018D,
        LB_GETTOPINDEX          = 0x018E,
        LB_FINDSTRING           = 0x018F,
        LB_GETSELCOUNT          = 0x0190,
        LB_GETSELITEMS          = 0x0191,
        LB_SETTABSTOPS          = 0x0192,
        LB_GETHORIZONTALEXTENT  = 0x0193,
        LB_SETHORIZONTALEXTENT  = 0x0194,
        LB_SETCOLUMNWIDTH       = 0x0195,
        LB_ADDFILE              = 0x0196,
        LB_SETTOPINDEX          = 0x0197,
        LB_GETITEMRECT          = 0x0198,
        LB_GETITEMDATA          = 0x0199,
        LB_SETITEMDATA          = 0x019A,
        LB_SELITEMRANGE         = 0x019B,
        LB_SETANCHORINDEX       = 0x019C,
        LB_GETANCHORINDEX       = 0x019D,
        LB_SETCARETINDEX        = 0x019E,
        LB_GETCARETINDEX        = 0x019F,
        LB_SETITEMHEIGHT        = 0x01A0,
        LB_GETITEMHEIGHT        = 0x01A1,
        LB_FINDSTRINGEXACT      = 0x01A2,
        LB_SETLOCALE            = 0x01A5,
        LB_GETLOCALE            = 0x01A6,
        LB_SETCOUNT             = 0x01A7,
        LB_INITSTORAGE          = 0x01A8,
        LB_ITEMFROMPOINT        = 0x01A9,
        LB_MULTIPLEADDSTRING    = 0x01B1,
        LB_GETLISTBOXINFO       = 0x01B2,
	} ListBoxMessages;

	typedef enum ListBoxStyles
	{
        LBS_NOTIFY            = 0x0001,
        LBS_SORT              = 0x0002,
        LBS_NOREDRAW          = 0x0004,
        LBS_MULTIPLESEL       = 0x0008,
        LBS_OWNERDRAWFIXED    = 0x0010,
        LBS_OWNERDRAWVARIABLE = 0x0020,
        LBS_HASSTRINGS        = 0x0040,
        LBS_USETABSTOPS       = 0x0080,
        LBS_NOINTEGRALHEIGHT  = 0x0100,
        LBS_MULTICOLUMN       = 0x0200,
        LBS_WANTKEYBOARDINPUT = 0x0400,
        LBS_EXTENDEDSEL       = 0x0800,
        LBS_DISABLENOSCROLL   = 0x1000,
        LBS_NODATA            = 0x2000,
        LBS_NOSEL             = 0x4000,
        LBS_COMBOBOX          = 0x8000,
        LBS_STANDARD         = 0xA00003, // (LBS_NOTIFY | LBS_SORT | WS_VSCROLL | WS_BORDER)
	} ListBoxStyles;

// ====== ComboBox Control =======
    [
        helpstring("ComboBox")
    ]
	module ComboBox {
        const LPSTR WC_COMBOBOX = "ComboBox";

    }

	typedef enum ComboBoxMessages
	{
        CB_GETEDITSEL               = 0x0140,
        CB_LIMITTEXT                = 0x0141,
        CB_SETEDITSEL               = 0x0142,
        CB_ADDSTRING                = 0x0143,
        CB_DELETESTRING             = 0x0144,
        CB_DIR                      = 0x0145,
        CB_GETCOUNT                 = 0x0146,
        CB_GETCURSEL                = 0x0147,
        CB_GETLBTEXT                = 0x0148,
        CB_GETLBTEXTLEN             = 0x0149,
        CB_INSERTSTRING             = 0x014A,
        CB_RESETCONTENT             = 0x014B,
        CB_FINDSTRING               = 0x014C,
        CB_SELECTSTRING             = 0x014D,
        CB_SETCURSEL                = 0x014E,
        CB_SHOWDROPDOWN             = 0x014F,
        CB_GETITEMDATA              = 0x0150,
        CB_SETITEMDATA              = 0x0151,
        CB_GETDROPPEDCONTROLRECT    = 0x0152,
        CB_SETITEMHEIGHT            = 0x0153,
        CB_GETITEMHEIGHT            = 0x0154,
        CB_SETEXTENDEDUI            = 0x0155,
        CB_GETEXTENDEDUI            = 0x0156,
        CB_GETDROPPEDSTATE          = 0x0157,
        CB_FINDSTRINGEXACT          = 0x0158,
        CB_SETLOCALE                = 0x0159,
        CB_GETLOCALE                = 0x015A,
        CB_GETTOPINDEX              = 0x015b,
        CB_SETTOPINDEX              = 0x015c,
        CB_GETHORIZONTALEXTENT      = 0x015d,
        CB_SETHORIZONTALEXTENT      = 0x015e,
        CB_GETDROPPEDWIDTH          = 0x015f,
        CB_SETDROPPEDWIDTH          = 0x0160,
        CB_INITSTORAGE              = 0x0161,
        CB_MULTIPLEADDSTRING        = 0x0163,
        CB_GETCOMBOBOXINFO          = 0x0164,
		CBM_FIRST = 0x1700,
		CB_SETMINVISIBLE       = (CBM_FIRST + 1),
		CB_GETMINVISIBLE       = (CBM_FIRST + 2),
		CB_SETCUEBANNER        = (CBM_FIRST + 3),
		CB_GETCUEBANNER        = (CBM_FIRST + 4),
	} ComboBoxMessages;

	typedef enum ComboBoxReturnValues 
	{
		CB_OKAY = 0,
		CB_ERR = (-1),
		CB_ERRSPACE = (-2),
	} ComboBoxReturnValues;

	typedef enum ComboBoxNotifications
	{
        CBN_ERRSPACE       = (-1),
        CBN_SELCHANGE      = 1,
        CBN_DBLCLK         = 2,
        CBN_SETFOCUS       = 3,
        CBN_KILLFOCUS      = 4,
        CBN_EDITCHANGE     = 5,
        CBN_EDITUPDATE     = 6,
        CBN_DROPDOWN       = 7,
        CBN_CLOSEUP        = 8,
        CBN_SELENDOK       = 9,
        CBN_SELENDCANCEL   = 10,
	} ComboBoxNotifications;

	typedef enum ComboBoxStyles
	{
        CBS_SIMPLE            = 0x0001,
        CBS_DROPDOWN          = 0x0002,
        CBS_DROPDOWNLIST      = 0x0003,
        CBS_OWNERDRAWFIXED    = 0x0010,
        CBS_OWNERDRAWVARIABLE = 0x0020,
        CBS_AUTOHSCROLL       = 0x0040,
        CBS_OEMCONVERT        = 0x0080,
        CBS_SORT              = 0x0100,
        CBS_HASSTRINGS        = 0x0200,
        CBS_NOINTEGRALHEIGHT  = 0x0400,
        CBS_DISABLENOSCROLL   = 0x0800,
        CBS_UPPERCASE         = 0x2000,
        CBS_LOWERCASE         = 0x4000,
	} ComboBoxStyles;

// =========  ScrollBar Control ========
    [
        helpstring("ScrollBar")
    ]
	module ScrollBar {
        const LPSTR WC_SCROLLBAR = "ScrollBar";

    }

	typedef enum ScrollBarStyles 
	{
        SBS_HORZ                    = 0x0000,
        SBS_VERT                    = 0x0001,
        SBS_TOPALIGN                = 0x0002,
        SBS_LEFTALIGN               = 0x0002,
        SBS_BOTTOMALIGN             = 0x0004,
        SBS_RIGHTALIGN              = 0x0004,
        SBS_SIZEBOXTOPLEFTALIGN     = 0x0002,
        SBS_SIZEBOXBOTTOMRIGHTALIGN = 0x0004,
        SBS_SIZEBOX                 = 0x0008,
        SBS_SIZEGRIP                = 0x0010,
	} ScrollBarStyles;

	typedef enum ScrollBarMessages
	{
        SBM_SETPOS                  = 0x00E0, /*not in win3.1 */
        SBM_GETPOS                  = 0x00E1, /*not in win3.1 */
        SBM_SETRANGE                = 0x00E2, /*not in win3.1 */
        SBM_SETRANGEREDRAW          = 0x00E6, /*not in win3.1 */
        SBM_GETRANGE                = 0x00E3, /*not in win3.1 */
        SBM_ENABLE_ARROWS           = 0x00E4, /*not in win3.1 */
        SBM_SETSCROLLINFO           = 0x00E9,
        SBM_GETSCROLLINFO           = 0x00EA,
        SBM_GETSCROLLBARINFO        = 0x00EB,
	} ScrollBarMessages;

	typedef enum ScrollInfoFlags
	{
        SIF_RANGE           = 0x0001,
        SIF_PAGE            = 0x0002,
        SIF_POS             = 0x0004,
        SIF_DISABLENOSCROLL = 0x0008,
        SIF_TRACKPOS        = 0x0010,
        SIF_ALL             = (SIF_RANGE | SIF_PAGE | SIF_POS | SIF_TRACKPOS),
	} ScrollInfoFlags;

	typedef struct SCROLLINFO
	{
		LONG    cbSize;
		ScrollInfoFlags    fMask;
		int     nMin;
		int     nMax;
		LONG    nPage;
		int     nPos;
		int     nTrackPos;
	}   SCROLLINFO;

    [
        helpstring("ScrollBarControl"),
        dllname("user32.dll")
    ]
    module ScrollBarControl {

        [entry("SetScrollInfo")]
		int SetScrollInfo(
			[in] LONG hwnd,
			[in] LONG nBar,
			[in] SCROLLINFO *lpsi,
			[in] BOOL redraw);

		[entry("GetScrollInfo")]
		BOOL GetScrollInfo(
			[in] LONG hwnd,
			[in] LONG nBar,
			[in, out] SCROLLINFO *lpsi);

	}

// ====== TaskDialog Control =======

	typedef enum TASKDIALOG_FLAGS
	{
		TDF_ENABLE_HYPERLINKS               = 0x0001,
		TDF_USE_HICON_MAIN                  = 0x0002,
		TDF_USE_HICON_FOOTER                = 0x0004,
		TDF_ALLOW_DIALOG_CANCELLATION       = 0x0008,
		TDF_USE_COMMAND_LINKS               = 0x0010,
		TDF_USE_COMMAND_LINKS_NO_ICON       = 0x0020,
		TDF_EXPAND_FOOTER_AREA              = 0x0040,
		TDF_EXPANDED_BY_DEFAULT             = 0x0080,
		TDF_VERIFICATION_FLAG_CHECKED       = 0x0100,
		TDF_SHOW_PROGRESS_BAR               = 0x0200,
		TDF_SHOW_MARQUEE_PROGRESS_BAR       = 0x0400,
		TDF_CALLBACK_TIMER                  = 0x0800,
		TDF_POSITION_RELATIVE_TO_WINDOW     = 0x1000,
		TDF_RTL_LAYOUT                      = 0x2000,
		TDF_NO_DEFAULT_RADIO_BUTTON         = 0x4000,
		TDF_CAN_BE_MINIMIZED                = 0x8000,
		TDF_NO_SET_FOREGROUND               = 0x00010000, // Win8+ Don't call SetForegroundWindow() when activating the dialog
		TDF_SIZE_TO_CONTENT                 = 0x01000000,   // used by ShellMessageBox to emulate MessageBox sizing behavior
	} TASKDIALOG_FLAGS;

	typedef enum _TASKDIALOG_MESSAGES
	{
		TDM_NAVIGATE_PAGE                   = (0x400+101),
		TDM_CLICK_BUTTON                    = (0x400+102), // wParam = Button ID
		TDM_SET_MARQUEE_PROGRESS_BAR        = (0x400+103), // wParam = 0 (nonMarque) wParam != 0 (Marquee)
		TDM_SET_PROGRESS_BAR_STATE          = (0x400+104), // wParam = new progress state
		TDM_SET_PROGRESS_BAR_RANGE          = (0x400+105), // lParam = MAKELPARAM(nMinRange), nMaxRange)
		TDM_SET_PROGRESS_BAR_POS            = (0x400+106), // wParam = new position
		TDM_SET_PROGRESS_BAR_MARQUEE        = (0x400+107), // wParam = 0 (stop marquee)), wParam != 0 (start marquee)), lparam = speed (milliseconds between repaints)
		TDM_SET_ELEMENT_TEXT                = (0x400+108), // wParam = element (TASKDIALOG_ELEMENTS)), lParam = new element text (LPCWSTR)
		TDM_CLICK_RADIO_BUTTON              = (0x400+110), // wParam = Radio Button ID
		TDM_ENABLE_BUTTON                   = (0x400+111), // lParam = 0 (disable)), lParam != 0 (enable)), wParam = Button ID
		TDM_ENABLE_RADIO_BUTTON             = (0x400+112), // lParam = 0 (disable)), lParam != 0 (enable)), wParam = Radio Button ID
		TDM_CLICK_VERIFICATION              = (0x400+113), // wParam = 0 (unchecked)), 1 (checked)), lParam = 1 (set key focus)
		TDM_UPDATE_ELEMENT_TEXT             = (0x400+114), // wParam = element (TASKDIALOG_ELEMENTS)), lParam = new element text (LPCWSTR)
		TDM_SET_BUTTON_ELEVATION_REQUIRED_STATE = (0x400+115), // wParam = Button ID), lParam = 0 (elevation not required)), lParam != 0 (elevation required)
		TDM_UPDATE_ICON                     = (0x400+116),  // wParam = icon element (TASKDIALOG_ICON_ELEMENTS)), lParam = new icon (hIcon if TDF_USE_HICON_* was set), PCWSTR otherwise)
	} TASKDIALOG_MESSAGES;

	typedef enum TASKDIALOG_NOTIFICATIONS
	{
		TDN_CREATED                         = 0,
		TDN_NAVIGATED                       = 1,
		TDN_BUTTON_CLICKED                  = 2,            // wParam = Button ID
		TDN_HYPERLINK_CLICKED               = 3,            // lParam = (LPCWSTR)pszHREF
		TDN_TIMER                           = 4,            // wParam = Milliseconds since dialog created or timer reset
		TDN_DESTROYED                       = 5,
		TDN_RADIO_BUTTON_CLICKED            = 6,            // wParam = Radio Button ID
		TDN_DIALOG_CONSTRUCTED              = 7,
		TDN_VERIFICATION_CLICKED            = 8,             // wParam = 1 if checkbox checked, 0 if not, lParam is unused and always 0
		TDN_HELP                            = 9,
		TDN_EXPANDO_BUTTON_CLICKED          = 10            // wParam = 0 (dialog is now collapsed), wParam != 0 (dialog is now expanded)
	} TASKDIALOG_NOTIFICATIONS;

	typedef struct TASKDIALOG_BUTTON
	{
		int     nButtonID;
		LONG    pszButtonText;
	} TASKDIALOG_BUTTON;
	typedef enum TASKDIALOG_ELEMENTS
	{
		TDE_CONTENT,
		TDE_EXPANDED_INFORMATION,
		TDE_FOOTER,
		TDE_MAIN_INSTRUCTION
	} TASKDIALOG_ELEMENTS;
	typedef enum TASKDIALOG_ICON_ELEMENTS
	{
		TDIE_ICON_MAIN,
		TDIE_ICON_FOOTER
	} TASKDIALOG_ICON_ELEMENTS;
	typedef enum TD_ICONS
	{
		TD_WARNING_ICON = (-1),
		TD_ERROR_ICON = (-2),
		TD_INFORMATION_ICON = (-3),
		TD_SHIELD_ICON = (-4),
		IDI_APPLICATION = 32512, // 'miniature picture of an application window
		IDI_QUESTION = 32514, //'round blue circle containing '?'

		TD_SHIELD_GRADIENT_ICON = (-5), //same image as TD_SHIELD_ICON; main message text on gradient blue background
		TD_SHIELD_WARNING_ICON = (-6), //exclamation point in yellow Shield shape; main message text on gradient orange background
		TD_SHIELD_ERROR_ICON = (-7), //X contained within Shield shape; main message text on gradient red background
		TD_SHIELD_OK_ICON = (-8), //Shield shape containing green checkmark; main message text on gradient green background
		TD_SHIELD_GRAY_ICON = (-9), //same image as TD_SHIELD_ICON; main message text on medium gray background
		TD_NO_ICON = 0, //no icon; text on white background
	} TD_ICONS;

	typedef enum TASKDIALOG_COMMON_BUTTON_FLAGS
	{
		TDCBF_OK_BUTTON            = 0x0001, // selected control return value IDOK
		TDCBF_YES_BUTTON           = 0x0002, // selected control return value IDYES
		TDCBF_NO_BUTTON            = 0x0004, // selected control return value IDNO
		TDCBF_CANCEL_BUTTON        = 0x0008, // selected control return value IDCANCEL
		TDCBF_RETRY_BUTTON         = 0x0010, // selected control return value IDRETRY
		TDCBF_CLOSE_BUTTON         = 0x0020  // selected control return value IDCLOSE
	} TASKDIALOG_COMMON_BUTTON_FLAGS;
	typedef struct _TASKDIALOGCONFIG
	{
		LONG        cbSize;
		LONG        hwndParent;                             // incorrectly named, this is the owner window, not a parent.
		LONG   hInstance;                              // used for MAKEINTRESOURCE() strings
		TASKDIALOG_FLAGS                dwFlags;            // TASKDIALOG_FLAGS (TDF_XXX) flags
		TASKDIALOG_COMMON_BUTTON_FLAGS  dwCommonButtons;    // TASKDIALOG_COMMON_BUTTON (TDCBF_XXX) flags
		LONG      pszWindowTitle;                         // string or MAKEINTRESOURCE()
		LONG	  hORpszMainIcon;
		LONG      pszMainInstruction;
		LONG      pszContent;
		LONG        cButtons;
		LONG      pButtons;
		int         nDefaultButton;
		LONG        cRadioButtons;
		LONG        pRadioButtons;
		int         nDefaultRadioButton;
		LONG      pszVerificationText;
		LONG      pszExpandedInformation;
		LONG      pszExpandedControlText;
		LONG      pszCollapsedControlText;
		LONG      hORpszFooterIcon;
		LONG      pszFooter;
		LONG      pfCallback;
		LONG      lpCallbackData;
		LONG       cxWidth;  // width of the Task Dialog's client area in DLU's. If 0, Task Dialog will calculate the ideal width.
	} TASKDIALOGCONFIG;	
    [
        helpstring("TaskDialog"),
        dllname("comctl32.dll")
    ]
    module TaskDialog {
		[entry("TaskDialogIndirect")]
		int TaskDialogIndirect(
			[in] TASKDIALOGCONFIG *pTaskConfig,
			[out] LONG *pnButton,
			[out] LONG *pnRadioButton,
			[out] LONG *pfVerificationChecked);

		[entry("TaskDialog")]
		int TaskDialog(
			[in] LONG hwndOwner,
			[in] LONG hInstance,
			[in] LONG pszWindowTitle,
			[in] LONG pszMainInstruction,
			[in] LONG pszContent,
			[in] TASKDIALOG_COMMON_BUTTON_FLAGS dwCommonButtons,
			[in] LONG pszIcon,
			[out] LONG *pnButton);
	}
// ====== TrackMouseEvent =======

    typedef enum TrackMouseEventMessages {
        WM_MOUSEHOVER = 0x02A1,
        WM_MOUSELEAVE = 0x02A3,
    } TrackMouseEventMessages;

    typedef enum TrackMouseEventFlags {
        TME_HOVER = 0x00000001,
        TME_LEAVE = 0x00000002,
        TME_NONCLIENT = 0x00000010,
        TME_QUERY = 0x40000000,
        TME_CANCEL = 0x80000000,
    } TrackMouseEventFlags;

    typedef enum  TrackMouseHoverTime {
        HOVER_DEFAULT = 0xFFFFFFFF,
    } TrackMouseHoverTime;

    typedef struct TRACKMOUSEEVENT {
        LONG cbSize;
        TrackMouseEventFlags dwFlags;
        LONG hwndTrack;
        LONG dwHoverTime;
    } TRACKMOUSEEVENT;

    [
        helpstring("TrackMouseEvent"),
        dllname("comctl32.dll")
    ]
    module TrackMouse {

        [entry("_TrackMouseEvent")]
        BOOL TrackMouseEvent(
            [in] TRACKMOUSEEVENT *lpEventTrack);
    }

 // FLAT ScrollBars

    typedef enum FlatScrollBarProps {
        WSB_PROP_CYVSCROLL = 0x00000001L,
        WSB_PROP_CXHSCROLL = 0x00000002L,
        WSB_PROP_CYHSCROLL = 0x00000004L,
        WSB_PROP_CXVSCROLL = 0x00000008L,
        WSB_PROP_CXHTHUMB = 0x00000010L,
        WSB_PROP_CYVTHUMB = 0x00000020L,
        WSB_PROP_VBKGCOLOR = 0x00000040L,
        WSB_PROP_HBKGCOLOR = 0x00000080L,
        WSB_PROP_VSTYLE = 0x00000100L,
        WSB_PROP_HSTYLE = 0x00000200L,
        WSB_PROP_WINSTYLE = 0x00000400L,
        WSB_PROP_PALETTE = 0x00000800L,
        WSB_PROP_MASK = 0x00000FFFL,
    } FlatScrollBarProps;

    typedef enum FlatScrollBarModes {
        FSB_FLAT_MODE = 2,
        FSB_ENCARTA_MODE = 1,
        FSB_REGULAR_MODE = 0,
    } FlatScrollBarModes;

    //typedef struct SCROLLINFO {
    //    LONG cbSize;
    //    LONG fMask;
    //    LONG nMin;
    //    LONG nMax;
    //    LONG nPage;
    //    LONG nPos;
    //    LONG nTrackPos;
    //} SCROLLINFO;

    [
        helpstring("Flat ScrollBars"),
        dllname("comctl32.dll")
    ]
    module FlatScrollBars {
        [entry("FlatSB_EnableScrollBar")]
        BOOL FlatSB_EnableScrollBar(
            [in] LONG hWnd,
            [in] LONG wSBFlags,
            [in] LONG wArrows);

        [entry("FlatSB_ShowScrollBar")]
        BOOL FlatSB_ShowScrollBar(
            [in] LONG hWnd,
            [in] LONG wSBFlags,
            [in] BOOL fShow);

        [entry("FlatSB_GetScrollRange")]
        BOOL FlatSB_GetScrollRange(
            [in] LONG hWnd,
            [in] LONG nBar,
            [out] LONG *lpMinPos,
            [out] LONG *lpMaxPos);

        [entry("FlatSB_GetScrollInfo")]
        BOOL FlatSB_GetScrollInfo(
            [in] LONG hWnd,
            [in] LONG fnbar,
            [out] SCROLLINFO *lpsi);

        [entry("FlatSB_GetScrollPos")]
        LONG FlatSB_GetScrollPos(
            [in] LONG hWnd,
            [in] LONG nBar);

        [entry("FlatSB_GetScrollProp")]
        BOOL FlatSB_GetScrollProp(
            [in] LONG hWnd,
            [in] FlatScrollBarProps propIndex,
            [out] LONG *Value);

        [entry("FlatSB_SetScrollPos")]
        LONG FlatSB_SetScrollPos(
            [in] LONG hWnd,
            [in] LONG nBar,
            [in] LONG pos,
            [in] BOOL fRedraw);

        [entry("FlatSB_SetScrollInfo")]
        LONG FlatSB_SetScrollInfo(
            [in] LONG hWnd,
            [in] LONG nBar,
            [in] SCROLLINFO *,
            [in] BOOL fRedraw);

        [entry("FlatSB_SetScrollRange")]
        LONG FlatSB_SetScrollRange(
            [in] LONG hWnd,
            [in] LONG nBar,
            [in] LONG min,
            [in] LONG max,
            [in] BOOL fRedraw);

        [entry("FlatSB_SetScrollProp")]
        BOOL FlatSB_SetScrollProp(
            [in] LONG hWnd,
            [in] FlatScrollBarProps index,
            [in] LONG newValue,
            [in] BOOL fRedraw);

        [entry("InitializeFlatSB")]
        BOOL InitializeFlatSB(
            [in] LONG hWnd);

        [entry("UninitializeFlatSB")]
        HRESULT UninitializeFlatSB(
            [in] LONG hWnd);

    } //  END FLAT SB


// ==========
// INTERFACES FOR UNDOCUMENTED LISTVIEW

[
    odl,
    uuid(00000114-0000-0000-C000-000000000046)
]
interface IOleWindow : IUnknown {

    HRESULT GetWindow(
        [out, retval] long *phwnd);

    HRESULT ContextSensitiveHelp(
        [in] BOOL fEnterMode);

};
[
	odl,
	uuid(44C09D56-8D3B-419D-A462-7B956B105B47)
]
interface IOwnerDataCallback : IUnknown
{
	HRESULT GetItemPosition(
		[in] int iItem,
		[in, out] POINT *pt);
	HRESULT SetItemPosition(
		[in] int iItem,
		[in] POINT *pt);
	HRESULT GetItemInGroup(
		[in] int groupIndex,
		[in] int groupWideItemIndex,
		[in, out] int *pTotalItemIndex);
	HRESULT GetItemGroup(
		[in] int iItem,
		[in] int occurenceIndex,
		[in, out] int *pGroupIndex);
	HRESULT GetItemGroupCount(
		[in] int iItem,
		[in, out] int *pOccurenceCount);
	HRESULT OnCacheHint(
		[in] LONG lviiFirst1,
		[in] LONG lviiFirst2,
		[in] LONG lviiLast1,
		[in] LONG lviiLast2);
}

//typedef enum PROPDESC_CONTROL_TYPE PROPDESC_CONTROL_TYPE;
//
//typedef enum PROPCTL_RECT_TYPE PROPCTL_RECT_TYPE;
[
	odl,
	uuid(6E71A510-732A-4557-9596-A827E36DAF8F)
]
interface IPropertyControlBase : IUnknown
{
	HRESULT Initialize(
		[in] IUnknown *pUnk,
		[in] LONG pct); //PROPDESC_CONTROL_TYPE pct
	HRESULT GetSize(
		[in] LONG prt, //PROPCTL_RECT_TYPE
		[in] LONG hdc,
		[in, out] SIZE *siz1,
		[in, out] SIZE *siz2);
	HRESULT SetWindowTheme(
		[in] LONG lpsz1,
		[in] LONG lpsz2);
	HRESULT SetFont(
		[in] LONG phf);
	HRESULT SetTextColor(
		[in] LONG clrText);
	HRESULT GetFlags(
		[out] LONG *dwFlags);
	HRESULT SetFlags(
		[in] LONG dwFlags);
	HRESULT AdjustWindowRectPCB(
		[in] LONG hWnd,
		[in, out] RECT *prc1,
		[in, out] RECT *prc2,
		[in] LONG unknown);
	HRESULT SetValue(
		[in] IUnknown *pUnk);
	HRESULT InvokeDefaultAction();
	HRESULT Destroy();
	HRESULT SetFormatFlags(
		[in] LONG dwFlags);
	HRESULT GetFormatFlags(
		[out] LONG *dwFlags);
};


[
	odl,
	uuid(5E82A4DD-9561-476A-8634-1BEBACBA4A38)
]
interface IPropertyControl : IPropertyControlBase
{
	HRESULT GetValue(
		[in] UUID* riid, 
		[in, out] LPVOID ppv);
	HRESULT Create(
		[in] LONG hWnd,
		[in] RECT *prc,
		[in, out] RECT *prc2,
		[in] LONG unknown);
	HRESULT SetPosition(
		[in] RECT *prc,
		[in] RECT *prc2);
	HRESULT IsModified(
		[out] BOOL *bModified);
	HRESULT SetModified(
		[in] BOOL bModified);
	HRESULT ValidationFailed(
		[in] LONG lpsz);
	HRESULT GetState(
		[out] LONG *pstate);
};

[
	odl,
	uuid(E6DFF6FD-BCD5-4162-9C65-A3B18C616FDB)
]
interface IDrawPropertyControl : IPropertyControlBase
{
	HRESULT GetDrawFlags([out] int* pdwFlags);
	HRESULT WindowlessDraw([in] LONG hDC,
						   [in] RECT *pRect,
						   [in] int a);
	long HasVisibleContent();
	HRESULT GetDisplayText([out] LONG* lpText);
	HRESULT GetTooltipInfo([in] LONG hDC, [in] SIZE *sz, [out] LONG* unn);
};

[
	odl,
	uuid(7AF7F355-1066-4E17-B1F2-19FE2F099CD2)
]
interface IPropertyValue : IUnknown
{
	HRESULT SetPropertyKey([in, out] PROPERTYKEY* pk);
	HRESULT GetPropertyKey([in, out] PROPERTYKEY* pk);
	HRESULT GetValue([in, out] VARIANT *pprop);
	HRESULT InitValue([in] VARIANT pprop);
};


	
[
	odl,
	uuid(11A66240-5489-42C2-AEBF-286FC831524C)
]
interface ISubItemCallback : IUnknown
{
	HRESULT GetSubItemTitle(
		[in] int subitemIndex,
		[in, out] LONG *lpszBuffer,
		[in] int BufferSize);
	HRESULT GetSubItemControl(
		[in] int arg1,
		[in] int arg2,
		[in] UUID *riid,
		[in, out] IPropertyControlBase **ppv);
	HRESULT BeginSubItemEdit(
		[in] LONG p1,
		[in] LONG p2,
		[in] LONG p3,
		[in] UUID* riid,
		[in, out] IPropertyControlBase **ppv);
	HRESULT EndSubItemEdit(
		[in] LONG p1,
		[in] LONG p2,
		[in] LONG p3,
		[in, out] IPropertyControl **ppc);
	HRESULT BeginGroupEdit(
		[in] LONG iGroup,
		[in] UUID* riid,
		[in, out] IPropertyControlBase **ppv);
	HRESULT EndGroupEdit(
		[in] LONG p1,
		[in] LONG p2,
		[in, out] IPropertyControl **ppc);
	HRESULT OnInvokeVerb(
		[in] LONG iVerb,
		[in] LONG lpsz);
};

[
	odl,
	uuid(E5B16AF2-3990-4681-A609-1F060CD14269),
	helpstring("IListView for Windows 7+")
]
interface IListView : IOleWindow
{
	HRESULT GetImageList(
		[in] int lIndex,
		[out] LONG *himl);
	HRESULT SetImageList(
		[in] int lIndex,
		[in] LONG himl,
		[out] LONG *phimlOld);
	HRESULT GetBackgroundColor(
		[out] COLORREF *clrBk);
	HRESULT SetBackgroundColor(
		[in] COLORREF clrBk);
	HRESULT GetTextColor(
		[out] COLORREF *clrText);
	HRESULT SetTextColor(
		[in] COLORREF clrText);
	HRESULT GetTextBackgroundColor(
		[out] COLORREF *clrTextBk);
	HRESULT SetTextBackgroundColor(
		[in] COLORREF clrTextBk);
	HRESULT GetHotLightColor(
		[out] COLORREF *clrHot);
	HRESULT SetHotLightColor(
		[in] COLORREF clrHot);
	HRESULT GetItemCount(
		[out] LONG *nItems);
	HRESULT SetItemCount(
		[in] int nItems,
		[in] DWORD nParam2);
	HRESULT GetItem(
		//[in, out]LVITEMW *tLVI);
		[in] LONG ptLVI);
	[helpstring("SetItem(VarPtr(lvitemw))")]
	HRESULT SetItem(
		[in] LVITEM *pLVI); 
	HRESULT GetItemState(
		[in] int iItem,
		[in] int iSubItem,
		[in] LONG mask,
		[out] LONG *pState);
	HRESULT SetItemState(
		[in] int iItem,
		[in] int iSubItem,
		[in] LONG mask,
		[in] LONG state);
	HRESULT GetItemText(
		[in] int iItem,
		[in] int iSubItem,
		[in, out] LPWSTR pBuffer,
		[in] int nBufferSize);
	HRESULT SetItemText(
		[in] int iItem,
		[in] int iSubItem,
		[in] LPWSTR pszText);
	HRESULT GetBackgroundImage(
		[in, out]LVBKIMAGE *lvbk);
	[helpstring("SetBackgroundImage(VarPtr(lvbkimage))")]
	HRESULT SetBackgroundImage(
		[in] LONG pLVBK);
	HRESULT GetFocusedColumn(
		[out] LONG *iCol);
	HRESULT SetSelectionFlags(
		[in] LONG mask,
		[in] LONG flags);
	HRESULT GetSelectedColumn(
		[out] LONG *iCol);
	HRESULT SetSelectedColumn(
		[in] LONG iCol);
	HRESULT GetView(
		[out] LONG *iView);
	HRESULT SetView(
		[in] LONG iView);
	HRESULT InsertItem(
		[in] LONG pItem,
		[in] LONG iIndex);
	HRESULT DeleteItem(
		[in] LONG iIndex);
	HRESULT DeleteAllItems();
	HRESULT UpdateItem(
		[in] LONG iIndex);
	HRESULT GetItemRect(
		[in] LONG pLVII,
		[in] int nRectType,
		[out] RECT *rc);
	HRESULT GetSubItemRect(
		[in] LONG pLVII,
		[in] int iSubItem,
		[in] int nRectType,
		[out] RECT *rc);
	HRESULT HitTestSubItem(
		[in, out]LVHITTESTINFO *pHitTestData);
	HRESULT GetIncrSearchString(
		[in] LPWSTR pStr,
		[in] int nBufferSize,
		[in, out] int *pCopiedChars);
	HRESULT GetItemSpacing(
		[in] BOOL smallIconView,
		[out] LONG *pHoriz,
		[out] LONG *pVert);
	HRESULT SetIconSpacing(
		[in] int nHoriz,
		[in] int nVert,
		[out] int *pHoriz,
		[out] int *pVert);
	HRESULT GetNextItem(
		//[in]LVITEMINDEX *lvii,
		[in] int lviiItem,
		[in] int lviiGroup,
		[in] LONG flags,
		[out]LVITEMINDEX *lvii);
	HRESULT FindItem(
		//[in]LVITEMINDEX *lvii,
		[in] int lviiItem,
		[in] int lviiGroup,
		[in]LVFINDINFO *lvfi,
		[out]LVITEMINDEX *lviiFound);
	HRESULT GetSelectionMark(
		[out]LVITEMINDEX *lvii);
	HRESULT SetSelectionMark(
		//[in]LVITEMINDEX *lvii,
		[in] int lviiItem,
		[in] int lviiGroup,
		[out]LVITEMINDEX *lviiprev);
	HRESULT GetItemPosition(
		//[in]LVITEMINDEX *lvii,
		[in] int lviiItem,
		[in] int lviiGroup,
		[out] POINT *pt);
	HRESULT SetItemPosition(
		[in] int *iIndex,
		[in] POINT *pt);
	HRESULT ScrollView(
		[in] int hdist,
		[in] int vdist);
	HRESULT EnsureItemVisible(
		//[in]LVITEMINDEX *lvii,
		[in] int lviiItem,
		[in] int lviiGroup,
		[in] BOOL fPartialOk);
	HRESULT EnsureSubItemVisible(
		//[in]LVITEMINDEX *lvii,
		[in] int lviiItem,
		[in] int lviiGroup,
		[in] int iSubItem);
	HRESULT EditSubItem(
		//[in]LVITEMINDEX *lvii,
		[in] int lviiItem,
		[in] int lviiGroup,
		[in] int iSubItem);
	HRESULT RedrawItems(
		[in] int iFirst,
		[in] int iLast);
	HRESULT ArrangeItems(
		[in] int mode);
	HRESULT RecomputeItems(
		[in] int unknwn);
	HRESULT GetEditControl(
		[out] LONG *hEdit);
	HRESULT EditLabel(
		//[in]LVITEMINDEX *lvii,
		[in] LONG iItem,
		[in] LONG iGroup,
		[in] LPWSTR pszInitial,
		[out] LONG *hEdit);
	HRESULT EditGroupLabel(
		[in] int iGroup);
	HRESULT CancelEditLabel();
	HRESULT GetEditItem(
		[out]LVITEMINDEX *lvii,
		[out] int *iSubItem);
	HRESULT HitTest(
		[in, out]LVHITTESTINFO *lvhti);
	HRESULT GetStringWidth(
		[in] LPWSTR pString,
		[out] int *pWidth);
	HRESULT GetColumn(
		[in] int iCol,
		[out]LVCOLUMN *lvcol);
	HRESULT SetColumn(
		[in] int iCol,
		[in]LVCOLUMN *lvcol);
	HRESULT GetColumnOrderArray(
		[in] int iNumOfColumns,
		[out] int *pCol);
	HRESULT SetColumnOrderArray(
		[in] int iNumOfColumns,
		[in] int pColumns);
	HRESULT GetHeaderControl(
		[out] LONG *hHeader);
	HRESULT InsertColumn(
		[in] int iInsertAt,
		[in]LVCOLUMN *lvcol,
		[out] int *pColIndex);
	HRESULT DeleteColumn(
		[in] int iIndex);
	HRESULT CreateDragImage(
		[in] int iItem,
		[in] POINT *ptUpperLeft,
		[out] LONG *phiml);
	HRESULT GetViewRect(
		[out] RECT *rc);
	HRESULT GetClientRect(
		[in] BOOL unknwn,
		[out] RECT *rc);
	HRESULT GetColumnWidth(
		[in] int iCol,
		[out] int *pWidth);
	HRESULT SetColumnWidth(
		[in] int iCol,
		[in] int width);
	HRESULT GetCallbackMask(
		[out] LONG *pMask);
	HRESULT SetCallbackMask(
		[in] LONG mask);
	HRESULT GetTopIndex(
		[out] int *index);
	HRESULT GetCountPerPage(
		[out] int *pCount);
	HRESULT GetOrigin(
		[out] POINT *pt);
	HRESULT GetSelectedCount(
		[out] int *pSelCnt);
	HRESULT SortItems(
		[in] BOOL unknwn,
		[in] LONG lParam,
		[in] LONG pfnCompare);
	HRESULT GetExtendedStyle(
		[out] LONG *dwStyle);
	HRESULT SetExtendedStyle(
		[in] LONG mask,
		[in] LONG dwStyleNew,
		[out] LONG *dwStyleOld);
	HRESULT GetHoverTime(
		[out] UINT *pTime);
	HRESULT SetHoverTime(
		[in] UINT time,
		[out] UINT *prevtime);
	HRESULT GetToolTip(
		[out] LONG *hToolTip);
	HRESULT SetToolTip(
		[in] LONG hToolTip,
		[out] LONG *hOldToolTip);
	HRESULT GetHotItem(
		[out]LVITEMINDEX *lvii);
	HRESULT SetHotItem(
		//[in]LVITEMINDEX *lvii,
		[in] int lviiItem,
		[in] int lviiGroup,
		[out]LVITEMINDEX *oldlvii);
	HRESULT GetHotCursor(
		[out] LONG *hCursor);
	HRESULT SetHotCursor(
		[in] LONG hCursor,
		[out] LONG *hOldCursor);
	HRESULT ApproximateViewRect(
		[in] int nItemCount,
		[out] int *pWidth,
		[out] int *pHeight);
	HRESULT SetRangeObject(
		[in] int unknwn,
		[in, out] LPVOID pObj);
	HRESULT GetWorkAreas(
		[in] int iNumOfWorkAreas,
		[out] RECT *rc);
	HRESULT SetWorkAreas(
		[in] int iNumOfWorkAreas,
		[in] RECT *rc);
	HRESULT GetWorkAreaCount(
		[out] int *nAreas);
	HRESULT ResetEmptyText();
	HRESULT EnableGroupView(
		[in] BOOL enbl);
	HRESULT IsGroupViewEnabled(
		[out] BOOL *pEnabled);
	HRESULT SortGroups(
		[in] LONG pfnGroupCompare,
		[in] void *lParam);
	HRESULT GetGroupInfo(
		[in] int unknwn1,
		[in] int iGroupId,
		[in, out]LVGROUP *lvg);
	HRESULT SetGroupInfo(
		[in] int unknwn,
		[in] int iGroupID,
		[in]LVGROUP *lvg);
	HRESULT GetGroupRect(
		[in] BOOL unknwn,
		[in] int iGroupID,
		[in] int nRectType,
		[out] RECT *rc);
	HRESULT GetGroupState(
		[in] int iGroupID,
		[in] LONG mask,
		[out] LONG *pState);
	HRESULT HasGroup(
		[in] int iGroupID,
		[out] BOOL *pHasGroup);
	HRESULT InsertGroup(
		[in] int insertAt,
		[in]LVGROUP *lvg,
		[out] int *pGroupID);
	HRESULT RemoveGroup(
		[in] int iGroupID);
	HRESULT InsertGroupSorted(
		[in]LVINSERTGROUPSORTED *lvigs,
		[out] int *pGroupID);
	HRESULT GetGroupMetrics(
		[in, out]LVGROUPMETRICS *lvgm);
	HRESULT SetGroupMetrics(
		[in]LVGROUPMETRICS *lvgm);
	HRESULT RemoveAllGroups();
	HRESULT GetFocusedGroup(
		[out] int *iGroupID);
	HRESULT GetGroupCount(
		[out] int *nCount);
	HRESULT SetOwnerDataCallback(
		[in] IOwnerDataCallback *pCallback);
	HRESULT GetTileViewInfo(
		[out]LVTILEVIEWINFO *pInfo);
	HRESULT SetTileViewInfo(
		[in]LVTILEVIEWINFO *pInfo);
	HRESULT GetTileInfo(
		[out]LVTILEINFO *pInfo);
	HRESULT SetTileInfo(
		[in]LVTILEINFO *pInfo);
	HRESULT GetInsertMark(
		[out]LVINSERTMARK *pInsertMark);
	HRESULT SetInsertMark(
		[in]LVINSERTMARK *pInsertMark);
	HRESULT GetInsertMarkRect(
		[out] RECT *rc);
	HRESULT GetInsertMarkColor(
		[out] COLORREF *clrMark);
	HRESULT SetInsertMarkColor(
		[in] COLORREF clrMark,
		[out] COLORREF *clrMarkOld);
	HRESULT HitTestInsertMark(
		[in] POINT *pt,
		[in]LVINSERTMARK *pMark);
	HRESULT SetInfoTip(
		[in]LVSETINFOTIP *pInfoTip);
	HRESULT GetOutlineColor(
		[out] COLORREF *clrOutline);
	HRESULT SetOutlineColor(
		[in] COLORREF clrOutline,
		[out] COLORREF *clrOutlineOld);
	HRESULT GetFrozenItem(
		[out] int *pItem);
	HRESULT SetFrozenItem(
		[in] int iItemSometimes,
		[in] int iItemOthertimes);
	HRESULT GetFrozenSlot(
		[out] RECT *rcUnknown);
	HRESULT SetFrozenSlot(
		[in] int unknwn,
		[in] POINT *ptUnknwn);
	HRESULT GetViewMargin(
		[out] RECT *rcMargin);
	HRESULT SetViewMargin(
		[in] RECT *rcMargin);
	HRESULT SetKeyboardSelected(
		//[in]LVITEMINDEX *lvii,
		[in] int lviiItem,
		[in] int lviiGroup);
	HRESULT MapIndexToId(
		[in] int iItem,
		[out] int *pItemId);
	HRESULT MapIdToIndex(
		[in] int iIndex,
		[out] int *pItem);
	HRESULT IsItemVisible(
		//[in]LVITEMINDEX *lvii,
		[in] int lviiItem,
		[in] int lviiGroup,
		[out] BOOL *pVisible);
	HRESULT EnableAlphaShadow(
		[in] BOOL enbl);
	HRESULT GetGroupSubsetCount(
		[out] int *pRows);
	HRESULT SetGroupSubsetCount(
		[in] int nRows);
	HRESULT GetVisibleSlotCount(
		[out] int *nCount);
	HRESULT GetColumnMarginRect(
		[out] RECT *rc);
	HRESULT SetSubItemCallback(
		[in] ISubItemCallback *pCallback);
	HRESULT GetVisibleItemRange(
		[out]LVITEMINDEX *pFirst,
		[out]LVITEMINDEX *pLast);
	HRESULT SetTypeAheadFlags(
		[in] UINT mask,
		[in] UINT flags);
}

[
	odl,
    uuid(88EB9442-913B-4AB4-A741-DD99DCB7558B)
]
interface IListViewFooterCallback : IUnknown
{
	HRESULT OnButtonClicked(
		[in] int itemIndex,
		[in] LONG lParam,
		[in, out] LONG *pRemoveFooter);
	HRESULT OnDestroyButton(
		[in] int ItemIndex,
		[in] LONG lParam);
}

[
    odl,
    uuid(F0034DA8-8A22-4151-8F16-2EBA76565BCC)
]
interface IListViewFooter : IUnknown
{
	HRESULT IsVisible(
		[in] LONG pVisible);
	HRESULT GetFooterFocus(
		[out] LONG *pItemIndex);
	HRESULT SetFooterFocus(
		[in] LONG pItemIndex);
	HRESULT SetIntroText(
		[in] LONG pText);
    HRESULT Show(
		[in] IListViewFooterCallback *pCallbackObject);
	HRESULT RemoveAllButtons();
	HRESULT InsertButton(
		[in] int insertAt,
		[in] LONG pText,
		[in] LONG pAltText,
		[in] LONG iconIndex,
		[in] LONG lParam);
	HRESULT GetButtonLParam(
		[in] int itemIndex,
		[out] LONG *lParam);
}

} // END LIBRARY
